(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// The MIT License (MIT)

// Typed.js | Copyright (c) 2014 Matt Boldt | www.mattboldt.com

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




! function($) {

    "use strict";

    var Typed = function(el, options) {

        // chosen element to manipulate text
        this.el = $(el);

        // options
        this.options = $.extend({}, $.fn.typed.defaults, options);

        // attribute to type into
        this.isInput = this.el.is('input');
        this.attr = this.options.attr;

        // show cursor
        this.showCursor = this.isInput ? false : this.options.showCursor;

        // text content of element
        this.elContent = this.attr ? this.el.attr(this.attr) : this.el.text()

        // html or plain text
        this.contentType = this.options.contentType;

        // typing speed
        this.typeSpeed = this.options.typeSpeed;

        // add a delay before typing starts
        this.startDelay = this.options.startDelay;

        // backspacing speed
        this.backSpeed = this.options.backSpeed;

        // amount of time to wait before backspacing
        this.backDelay = this.options.backDelay;

        // input strings of text
        this.strings = this.options.strings;

        // character number position of current string
        this.strPos = 0;

        // current array position
        this.arrayPos = 0;

        // number to stop backspacing on.
        // default 0, can change depending on how many chars
        // you want to remove at the time
        this.stopNum = 0;

        // Looping logic
        this.loop = this.options.loop;
        this.loopCount = this.options.loopCount;
        this.curLoop = 0;

        // for stopping
        this.stop = false;

        // custom cursor
        this.cursorChar = this.options.cursorChar;

        // shuffle the strings
        this.shuffle = this.options.shuffle;
        // the order of strings
        this.sequence = [];

        // All systems go!
        this.build();
    };

    Typed.prototype = {

        constructor: Typed

        ,
        init: function() {
            // begin the loop w/ first current string (global self.string)
            // current string will be passed as an argument each time after this
            var self = this;
            self.timeout = setTimeout(function() {
                for (var i=0;i<self.strings.length;++i) self.sequence[i]=i;

                // shuffle the array if true
                if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);

                // Start typing
                self.typewrite(self.strings[self.sequence[self.arrayPos]], self.strPos);
            }, self.startDelay);
        }

        ,
        build: function() {
            // Insert cursor
            if (this.showCursor === true) {
                this.cursor = $("<span class=\"typed-cursor\">" + this.cursorChar + "</span>");
                this.el.after(this.cursor);
            }
            this.init();
        }

        // pass current string state to each function, types 1 char per call
        ,
        typewrite: function(curString, curStrPos) {
            // exit when stopped
            if (this.stop === true) {
                return;
            }

            // varying values for setTimeout during typing
            // can't be global since number changes each time loop is executed
            var humanize = Math.round(Math.random() * (100 - 30)) + this.typeSpeed;
            var self = this;

            // ------------- optional ------------- //
            // backpaces a certain string faster
            // ------------------------------------ //
            // if (self.arrayPos == 1){
            //  self.backDelay = 50;
            // }
            // else{ self.backDelay = 500; }

            // contain typing function in a timeout humanize'd delay
            self.timeout = setTimeout(function() {
                // check for an escape character before a pause value
                // format: \^\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^
                // single ^ are removed from string
                var charPause = 0;
                var substr = curString.substr(curStrPos);
                if (substr.charAt(0) === '^') {
                    var skip = 1; // skip atleast 1
                    if (/^\^\d+/.test(substr)) {
                        substr = /\d+/.exec(substr)[0];
                        skip += substr.length;
                        charPause = parseInt(substr);
                    }

                    // strip out the escape character and pause value so they're not printed
                    curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);
                }

                if (self.contentType === 'html') {
                    // skip over html tags while typing
                    var curChar = curString.substr(curStrPos).charAt(0)
                    if (curChar === '<' || curChar === '&') {
                        var tag = '';
                        var endTag = '';
                        if (curChar === '<') {
                            endTag = '>'
                        } else {
                            endTag = ';'
                        }
                        while (curString.substr(curStrPos).charAt(0) !== endTag) {
                            tag += curString.substr(curStrPos).charAt(0);
                            curStrPos++;
                        }
                        curStrPos++;
                        tag += endTag;
                    }
                }

                // timeout for any pause after a character
                self.timeout = setTimeout(function() {
                    if (curStrPos === curString.length) {
                        // fires callback function
                        self.options.onStringTyped(self.arrayPos);

                        // is this the final string
                        if (self.arrayPos === self.strings.length - 1) {
                            // animation that occurs on the last typed string
                            self.options.callback();

                            self.curLoop++;

                            // quit if we wont loop back
                            if (self.loop === false || self.curLoop === self.loopCount)
                                return;
                        }

                        self.timeout = setTimeout(function() {
                            self.backspace(curString, curStrPos);
                        }, self.backDelay);
                    } else {

                        /* call before functions if applicable */
                        if (curStrPos === 0)
                            self.options.preStringTyped(self.arrayPos);

                        // start typing each new char into existing string
                        // curString: arg, self.el.html: original text inside element
                        var nextString = curString.substr(0, curStrPos + 1);
                        if (self.attr) {
                            self.el.attr(self.attr, nextString);
                        } else {
                            if (self.isInput) {
                                self.el.val(nextString);
                            } else if (self.contentType === 'html') {
                                self.el.html(nextString);
                            } else {
                                self.el.text(nextString);
                            }
                        }

                        // add characters one by one
                        curStrPos++;
                        // loop the function
                        self.typewrite(curString, curStrPos);
                    }
                    // end of character pause
                }, charPause);

                // humanized value for typing
            }, humanize);

        }

        ,
        backspace: function(curString, curStrPos) {
            // exit when stopped
            if (this.stop === true) {
                return;
            }

            // varying values for setTimeout during typing
            // can't be global since number changes each time loop is executed
            var humanize = Math.round(Math.random() * (100 - 30)) + this.backSpeed;
            var self = this;

            self.timeout = setTimeout(function() {

                // ----- this part is optional ----- //
                // check string array position
                // on the first string, only delete one word
                // the stopNum actually represents the amount of chars to
                // keep in the current string. In my case it's 14.
                // if (self.arrayPos == 1){
                //  self.stopNum = 14;
                // }
                //every other time, delete the whole typed string
                // else{
                //  self.stopNum = 0;
                // }

                if (self.contentType === 'html') {
                    // skip over html tags while backspacing
                    if (curString.substr(curStrPos).charAt(0) === '>') {
                        var tag = '';
                        while (curString.substr(curStrPos).charAt(0) !== '<') {
                            tag -= curString.substr(curStrPos).charAt(0);
                            curStrPos--;
                        }
                        curStrPos--;
                        tag += '<';
                    }
                }

                // ----- continue important stuff ----- //
                // replace text with base text + typed characters
                var nextString = curString.substr(0, curStrPos);
                if (self.attr) {
                    self.el.attr(self.attr, nextString);
                } else {
                    if (self.isInput) {
                        self.el.val(nextString);
                    } else if (self.contentType === 'html') {
                        self.el.html(nextString);
                    } else {
                        self.el.text(nextString);
                    }
                }

                // if the number (id of character in current string) is
                // less than the stop number, keep going
                if (curStrPos > self.stopNum) {
                    // subtract characters one by one
                    curStrPos--;
                    // loop the function
                    self.backspace(curString, curStrPos);
                }
                // if the stop number has been reached, increase
                // array position to next string
                else if (curStrPos <= self.stopNum) {
                    self.arrayPos++;

                    if (self.arrayPos === self.strings.length) {
                        self.arrayPos = 0;

                        // Shuffle sequence again
                        if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);

                        self.init();
                    } else
                        self.typewrite(self.strings[self.sequence[self.arrayPos]], curStrPos);
                }

                // humanized value for typing
            }, humanize);

        }
        /**
         * Shuffles the numbers in the given array.
         * @param {Array} array
         * @returns {Array}
         */
        ,shuffleArray: function(array) {
            var tmp, current, top = array.length;
            if(top) while(--top) {
                current = Math.floor(Math.random() * (top + 1));
                tmp = array[current];
                array[current] = array[top];
                array[top] = tmp;
            }
            return array;
        }

        // Start & Stop currently not working

        // , stop: function() {
        //     var self = this;

        //     self.stop = true;
        //     clearInterval(self.timeout);
        // }

        // , start: function() {
        //     var self = this;
        //     if(self.stop === false)
        //        return;

        //     this.stop = false;
        //     this.init();
        // }

        // Reset and rebuild the element
        ,
        reset: function() {
            var self = this;
            clearInterval(self.timeout);
            var id = this.el.attr('id');
            this.el.after('<span id="' + id + '"/>')
            this.el.remove();
            if (typeof this.cursor !== 'undefined') {
                this.cursor.remove();
            }
            // Send the callback
            self.options.resetCallback();
        }

    };

    $.fn.typed = function(option) {
        return this.each(function() {
            var $this = $(this),
                data = $this.data('typed'),
                options = typeof option == 'object' && option;
            if (!data) $this.data('typed', (data = new Typed(this, options)));
            if (typeof option == 'string') data[option]();
        });
    };

    $.fn.typed.defaults = {
        strings: ["These are the default values...", "You know what you should do?", "Use your own!", "Have a great day!"],
        // typing speed
        typeSpeed: 0,
        // time before typing starts
        startDelay: 0,
        // backspacing speed
        backSpeed: 0,
        // shuffle the strings
        shuffle: false,
        // time before backspacing
        backDelay: 500,
        // loop
        loop: false,
        // false = infinite
        loopCount: false,
        // show cursor
        showCursor: true,
        // character for cursor
        cursorChar: "|",
        // attribute to type (null == text)
        attr: null,
        // either html or text
        contentType: 'html',
        // call when done callback function
        callback: function() {},
        // starting callback function before each string
        preStringTyped: function() {},
        //callback for every typed string
        onStringTyped: function() {},
        // callback for reset
        resetCallback: function() {}
    };


}(window.jQuery);

},{}],2:[function(require,module,exports){
;(function(){
  var mainModule = {};

  publicMethod();
  init();
  attachEvents();

  function init() {
     $('.intro__text1').typed({
        strings: ["I'm Anton Povzun."],
        typeSpeed: 50,
        showCursor: false,
        callback: introText2
     });
     
  };

  function attachEvents() {
    
  };

  function introText2() {
    $('.intro__text2').typed({
        strings: ["A robot from the future", "A front-end developer "],
        typeSpeed: 50,
        backDelay: 700,
        showCursor: false,
        callback: introText3
     });
  };

  function introText3() {
    $('.intro__text3').typed({
        strings: ["I like to make cool stuff."],
        showCursor: false,
        typeSpeed: 50
     });
  };

  function publicMethod() {
    mainModule = {
      
    }
  };

  window.mainModule = mainModule;
})();

},{}],3:[function(require,module,exports){
var type = require('../bower/typed.js/js/typed.js');
var main = require('./_modules/main.js');
},{"../bower/typed.js/js/typed.js":1,"./_modules/main.js":2}]},{},[3])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxPcGVuc2VydmVyXFxkb21haW5zXFxwb3J0Zm9saW9cXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkQ6L09wZW5zZXJ2ZXIvZG9tYWlucy9wb3J0Zm9saW8vYXBwL2Jvd2VyL3R5cGVkLmpzL2pzL3R5cGVkLmpzIiwiRDovT3BlbnNlcnZlci9kb21haW5zL3BvcnRmb2xpby9hcHAvanMvX21vZHVsZXMvbWFpbi5qcyIsIkQ6L09wZW5zZXJ2ZXIvZG9tYWlucy9wb3J0Zm9saW8vYXBwL2pzL2Zha2VfMTA3NGExNzguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gVGhlIE1JVCBMaWNlbnNlIChNSVQpXG5cbi8vIFR5cGVkLmpzIHwgQ29weXJpZ2h0IChjKSAyMDE0IE1hdHQgQm9sZHQgfCB3d3cubWF0dGJvbGR0LmNvbVxuXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4vLyBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4vLyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4vLyBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cblxuXG5cbiEgZnVuY3Rpb24oJCkge1xuXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgVHlwZWQgPSBmdW5jdGlvbihlbCwgb3B0aW9ucykge1xuXG4gICAgICAgIC8vIGNob3NlbiBlbGVtZW50IHRvIG1hbmlwdWxhdGUgdGV4dFxuICAgICAgICB0aGlzLmVsID0gJChlbCk7XG5cbiAgICAgICAgLy8gb3B0aW9uc1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi50eXBlZC5kZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYXR0cmlidXRlIHRvIHR5cGUgaW50b1xuICAgICAgICB0aGlzLmlzSW5wdXQgPSB0aGlzLmVsLmlzKCdpbnB1dCcpO1xuICAgICAgICB0aGlzLmF0dHIgPSB0aGlzLm9wdGlvbnMuYXR0cjtcblxuICAgICAgICAvLyBzaG93IGN1cnNvclxuICAgICAgICB0aGlzLnNob3dDdXJzb3IgPSB0aGlzLmlzSW5wdXQgPyBmYWxzZSA6IHRoaXMub3B0aW9ucy5zaG93Q3Vyc29yO1xuXG4gICAgICAgIC8vIHRleHQgY29udGVudCBvZiBlbGVtZW50XG4gICAgICAgIHRoaXMuZWxDb250ZW50ID0gdGhpcy5hdHRyID8gdGhpcy5lbC5hdHRyKHRoaXMuYXR0cikgOiB0aGlzLmVsLnRleHQoKVxuXG4gICAgICAgIC8vIGh0bWwgb3IgcGxhaW4gdGV4dFxuICAgICAgICB0aGlzLmNvbnRlbnRUeXBlID0gdGhpcy5vcHRpb25zLmNvbnRlbnRUeXBlO1xuXG4gICAgICAgIC8vIHR5cGluZyBzcGVlZFxuICAgICAgICB0aGlzLnR5cGVTcGVlZCA9IHRoaXMub3B0aW9ucy50eXBlU3BlZWQ7XG5cbiAgICAgICAgLy8gYWRkIGEgZGVsYXkgYmVmb3JlIHR5cGluZyBzdGFydHNcbiAgICAgICAgdGhpcy5zdGFydERlbGF5ID0gdGhpcy5vcHRpb25zLnN0YXJ0RGVsYXk7XG5cbiAgICAgICAgLy8gYmFja3NwYWNpbmcgc3BlZWRcbiAgICAgICAgdGhpcy5iYWNrU3BlZWQgPSB0aGlzLm9wdGlvbnMuYmFja1NwZWVkO1xuXG4gICAgICAgIC8vIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGJhY2tzcGFjaW5nXG4gICAgICAgIHRoaXMuYmFja0RlbGF5ID0gdGhpcy5vcHRpb25zLmJhY2tEZWxheTtcblxuICAgICAgICAvLyBpbnB1dCBzdHJpbmdzIG9mIHRleHRcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gdGhpcy5vcHRpb25zLnN0cmluZ3M7XG5cbiAgICAgICAgLy8gY2hhcmFjdGVyIG51bWJlciBwb3NpdGlvbiBvZiBjdXJyZW50IHN0cmluZ1xuICAgICAgICB0aGlzLnN0clBvcyA9IDA7XG5cbiAgICAgICAgLy8gY3VycmVudCBhcnJheSBwb3NpdGlvblxuICAgICAgICB0aGlzLmFycmF5UG9zID0gMDtcblxuICAgICAgICAvLyBudW1iZXIgdG8gc3RvcCBiYWNrc3BhY2luZyBvbi5cbiAgICAgICAgLy8gZGVmYXVsdCAwLCBjYW4gY2hhbmdlIGRlcGVuZGluZyBvbiBob3cgbWFueSBjaGFyc1xuICAgICAgICAvLyB5b3Ugd2FudCB0byByZW1vdmUgYXQgdGhlIHRpbWVcbiAgICAgICAgdGhpcy5zdG9wTnVtID0gMDtcblxuICAgICAgICAvLyBMb29waW5nIGxvZ2ljXG4gICAgICAgIHRoaXMubG9vcCA9IHRoaXMub3B0aW9ucy5sb29wO1xuICAgICAgICB0aGlzLmxvb3BDb3VudCA9IHRoaXMub3B0aW9ucy5sb29wQ291bnQ7XG4gICAgICAgIHRoaXMuY3VyTG9vcCA9IDA7XG5cbiAgICAgICAgLy8gZm9yIHN0b3BwaW5nXG4gICAgICAgIHRoaXMuc3RvcCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIGN1c3RvbSBjdXJzb3JcbiAgICAgICAgdGhpcy5jdXJzb3JDaGFyID0gdGhpcy5vcHRpb25zLmN1cnNvckNoYXI7XG5cbiAgICAgICAgLy8gc2h1ZmZsZSB0aGUgc3RyaW5nc1xuICAgICAgICB0aGlzLnNodWZmbGUgPSB0aGlzLm9wdGlvbnMuc2h1ZmZsZTtcbiAgICAgICAgLy8gdGhlIG9yZGVyIG9mIHN0cmluZ3NcbiAgICAgICAgdGhpcy5zZXF1ZW5jZSA9IFtdO1xuXG4gICAgICAgIC8vIEFsbCBzeXN0ZW1zIGdvIVxuICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfTtcblxuICAgIFR5cGVkLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBjb25zdHJ1Y3RvcjogVHlwZWRcblxuICAgICAgICAsXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gYmVnaW4gdGhlIGxvb3Agdy8gZmlyc3QgY3VycmVudCBzdHJpbmcgKGdsb2JhbCBzZWxmLnN0cmluZylcbiAgICAgICAgICAgIC8vIGN1cnJlbnQgc3RyaW5nIHdpbGwgYmUgcGFzc2VkIGFzIGFuIGFyZ3VtZW50IGVhY2ggdGltZSBhZnRlciB0aGlzXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGk9MDtpPHNlbGYuc3RyaW5ncy5sZW5ndGg7KytpKSBzZWxmLnNlcXVlbmNlW2ldPWk7XG5cbiAgICAgICAgICAgICAgICAvLyBzaHVmZmxlIHRoZSBhcnJheSBpZiB0cnVlXG4gICAgICAgICAgICAgICAgaWYoc2VsZi5zaHVmZmxlKSBzZWxmLnNlcXVlbmNlID0gc2VsZi5zaHVmZmxlQXJyYXkoc2VsZi5zZXF1ZW5jZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBTdGFydCB0eXBpbmdcbiAgICAgICAgICAgICAgICBzZWxmLnR5cGV3cml0ZShzZWxmLnN0cmluZ3Nbc2VsZi5zZXF1ZW5jZVtzZWxmLmFycmF5UG9zXV0sIHNlbGYuc3RyUG9zKTtcbiAgICAgICAgICAgIH0sIHNlbGYuc3RhcnREZWxheSk7XG4gICAgICAgIH1cblxuICAgICAgICAsXG4gICAgICAgIGJ1aWxkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEluc2VydCBjdXJzb3JcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dDdXJzb3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9ICQoXCI8c3BhbiBjbGFzcz1cXFwidHlwZWQtY3Vyc29yXFxcIj5cIiArIHRoaXMuY3Vyc29yQ2hhciArIFwiPC9zcGFuPlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmFmdGVyKHRoaXMuY3Vyc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGFzcyBjdXJyZW50IHN0cmluZyBzdGF0ZSB0byBlYWNoIGZ1bmN0aW9uLCB0eXBlcyAxIGNoYXIgcGVyIGNhbGxcbiAgICAgICAgLFxuICAgICAgICB0eXBld3JpdGU6IGZ1bmN0aW9uKGN1clN0cmluZywgY3VyU3RyUG9zKSB7XG4gICAgICAgICAgICAvLyBleGl0IHdoZW4gc3RvcHBlZFxuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFyeWluZyB2YWx1ZXMgZm9yIHNldFRpbWVvdXQgZHVyaW5nIHR5cGluZ1xuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgZ2xvYmFsIHNpbmNlIG51bWJlciBjaGFuZ2VzIGVhY2ggdGltZSBsb29wIGlzIGV4ZWN1dGVkXG4gICAgICAgICAgICB2YXIgaHVtYW5pemUgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoMTAwIC0gMzApKSArIHRoaXMudHlwZVNwZWVkO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyAtLS0tLS0tLS0tLS0tIG9wdGlvbmFsIC0tLS0tLS0tLS0tLS0gLy9cbiAgICAgICAgICAgIC8vIGJhY2twYWNlcyBhIGNlcnRhaW4gc3RyaW5nIGZhc3RlclxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG4gICAgICAgICAgICAvLyBpZiAoc2VsZi5hcnJheVBvcyA9PSAxKXtcbiAgICAgICAgICAgIC8vICBzZWxmLmJhY2tEZWxheSA9IDUwO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gZWxzZXsgc2VsZi5iYWNrRGVsYXkgPSA1MDA7IH1cblxuICAgICAgICAgICAgLy8gY29udGFpbiB0eXBpbmcgZnVuY3Rpb24gaW4gYSB0aW1lb3V0IGh1bWFuaXplJ2QgZGVsYXlcbiAgICAgICAgICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGFuIGVzY2FwZSBjaGFyYWN0ZXIgYmVmb3JlIGEgcGF1c2UgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyBmb3JtYXQ6IFxcXlxcZCsgLi4gZWc6IF4xMDAwIC4uIHNob3VsZCBiZSBhYmxlIHRvIHByaW50IHRoZSBeIHRvbyB1c2luZyBeXlxuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBeIGFyZSByZW1vdmVkIGZyb20gc3RyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGNoYXJQYXVzZSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnN0ciA9IGN1clN0cmluZy5zdWJzdHIoY3VyU3RyUG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic3RyLmNoYXJBdCgwKSA9PT0gJ14nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBza2lwID0gMTsgLy8gc2tpcCBhdGxlYXN0IDFcbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eXFxeXFxkKy8udGVzdChzdWJzdHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzdHIgPSAvXFxkKy8uZXhlYyhzdWJzdHIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcCArPSBzdWJzdHIubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhclBhdXNlID0gcGFyc2VJbnQoc3Vic3RyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmlwIG91dCB0aGUgZXNjYXBlIGNoYXJhY3RlciBhbmQgcGF1c2UgdmFsdWUgc28gdGhleSdyZSBub3QgcHJpbnRlZFxuICAgICAgICAgICAgICAgICAgICBjdXJTdHJpbmcgPSBjdXJTdHJpbmcuc3Vic3RyaW5nKDAsIGN1clN0clBvcykgKyBjdXJTdHJpbmcuc3Vic3RyaW5nKGN1clN0clBvcyArIHNraXApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBvdmVyIGh0bWwgdGFncyB3aGlsZSB0eXBpbmdcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1ckNoYXIgPSBjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcykuY2hhckF0KDApXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJDaGFyID09PSAnPCcgfHwgY3VyQ2hhciA9PT0gJyYnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kVGFnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hhciA9PT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kVGFnID0gJz4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRhZyA9ICc7J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1clN0cmluZy5zdWJzdHIoY3VyU3RyUG9zKS5jaGFyQXQoMCkgIT09IGVuZFRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArPSBjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcykuY2hhckF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1clN0clBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyU3RyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YWcgKz0gZW5kVGFnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdGltZW91dCBmb3IgYW55IHBhdXNlIGFmdGVyIGEgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1clN0clBvcyA9PT0gY3VyU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmlyZXMgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5vblN0cmluZ1R5cGVkKHNlbGYuYXJyYXlQb3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpcyB0aGlzIHRoZSBmaW5hbCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFycmF5UG9zID09PSBzZWxmLnN0cmluZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuaW1hdGlvbiB0aGF0IG9jY3VycyBvbiB0aGUgbGFzdCB0eXBlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMuY2FsbGJhY2soKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuY3VyTG9vcCsrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVpdCBpZiB3ZSB3b250IGxvb3AgYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmxvb3AgPT09IGZhbHNlIHx8IHNlbGYuY3VyTG9vcCA9PT0gc2VsZi5sb29wQ291bnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmJhY2tzcGFjZShjdXJTdHJpbmcsIGN1clN0clBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBzZWxmLmJhY2tEZWxheSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNhbGwgYmVmb3JlIGZ1bmN0aW9ucyBpZiBhcHBsaWNhYmxlICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyU3RyUG9zID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYub3B0aW9ucy5wcmVTdHJpbmdUeXBlZChzZWxmLmFycmF5UG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgdHlwaW5nIGVhY2ggbmV3IGNoYXIgaW50byBleGlzdGluZyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1clN0cmluZzogYXJnLCBzZWxmLmVsLmh0bWw6IG9yaWdpbmFsIHRleHQgaW5zaWRlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0U3RyaW5nID0gY3VyU3RyaW5nLnN1YnN0cigwLCBjdXJTdHJQb3MgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsLmF0dHIoc2VsZi5hdHRyLCBuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuaXNJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsLnZhbChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuY29udGVudFR5cGUgPT09ICdodG1sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsLmh0bWwobmV4dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC50ZXh0KG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGNoYXJhY3RlcnMgb25lIGJ5IG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyU3RyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi50eXBld3JpdGUoY3VyU3RyaW5nLCBjdXJTdHJQb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGVuZCBvZiBjaGFyYWN0ZXIgcGF1c2VcbiAgICAgICAgICAgICAgICB9LCBjaGFyUGF1c2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gaHVtYW5pemVkIHZhbHVlIGZvciB0eXBpbmdcbiAgICAgICAgICAgIH0sIGh1bWFuaXplKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLFxuICAgICAgICBiYWNrc3BhY2U6IGZ1bmN0aW9uKGN1clN0cmluZywgY3VyU3RyUG9zKSB7XG4gICAgICAgICAgICAvLyBleGl0IHdoZW4gc3RvcHBlZFxuICAgICAgICAgICAgaWYgKHRoaXMuc3RvcCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdmFyeWluZyB2YWx1ZXMgZm9yIHNldFRpbWVvdXQgZHVyaW5nIHR5cGluZ1xuICAgICAgICAgICAgLy8gY2FuJ3QgYmUgZ2xvYmFsIHNpbmNlIG51bWJlciBjaGFuZ2VzIGVhY2ggdGltZSBsb29wIGlzIGV4ZWN1dGVkXG4gICAgICAgICAgICB2YXIgaHVtYW5pemUgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoMTAwIC0gMzApKSArIHRoaXMuYmFja1NwZWVkO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgLy8gLS0tLS0gdGhpcyBwYXJ0IGlzIG9wdGlvbmFsIC0tLS0tIC8vXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgc3RyaW5nIGFycmF5IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgLy8gb24gdGhlIGZpcnN0IHN0cmluZywgb25seSBkZWxldGUgb25lIHdvcmRcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RvcE51bSBhY3R1YWxseSByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgY2hhcnMgdG9cbiAgICAgICAgICAgICAgICAvLyBrZWVwIGluIHRoZSBjdXJyZW50IHN0cmluZy4gSW4gbXkgY2FzZSBpdCdzIDE0LlxuICAgICAgICAgICAgICAgIC8vIGlmIChzZWxmLmFycmF5UG9zID09IDEpe1xuICAgICAgICAgICAgICAgIC8vICBzZWxmLnN0b3BOdW0gPSAxNDtcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy9ldmVyeSBvdGhlciB0aW1lLCBkZWxldGUgdGhlIHdob2xlIHR5cGVkIHN0cmluZ1xuICAgICAgICAgICAgICAgIC8vIGVsc2V7XG4gICAgICAgICAgICAgICAgLy8gIHNlbGYuc3RvcE51bSA9IDA7XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY29udGVudFR5cGUgPT09ICdodG1sJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBza2lwIG92ZXIgaHRtbCB0YWdzIHdoaWxlIGJhY2tzcGFjaW5nXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcykuY2hhckF0KDApID09PSAnPicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWcgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcykuY2hhckF0KDApICE9PSAnPCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgLT0gY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJTdHJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clN0clBvcy0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnICs9ICc8JztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIC0tLS0tIGNvbnRpbnVlIGltcG9ydGFudCBzdHVmZiAtLS0tLSAvL1xuICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGV4dCB3aXRoIGJhc2UgdGV4dCArIHR5cGVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFN0cmluZyA9IGN1clN0cmluZy5zdWJzdHIoMCwgY3VyU3RyUG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZWwuYXR0cihzZWxmLmF0dHIsIG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWwudmFsKG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGYuY29udGVudFR5cGUgPT09ICdodG1sJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC5odG1sKG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC50ZXh0KG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG51bWJlciAoaWQgb2YgY2hhcmFjdGVyIGluIGN1cnJlbnQgc3RyaW5nKSBpc1xuICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3RvcCBudW1iZXIsIGtlZXAgZ29pbmdcbiAgICAgICAgICAgICAgICBpZiAoY3VyU3RyUG9zID4gc2VsZi5zdG9wTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1YnRyYWN0IGNoYXJhY3RlcnMgb25lIGJ5IG9uZVxuICAgICAgICAgICAgICAgICAgICBjdXJTdHJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5iYWNrc3BhY2UoY3VyU3RyaW5nLCBjdXJTdHJQb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgc3RvcCBudW1iZXIgaGFzIGJlZW4gcmVhY2hlZCwgaW5jcmVhc2VcbiAgICAgICAgICAgICAgICAvLyBhcnJheSBwb3NpdGlvbiB0byBuZXh0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1clN0clBvcyA8PSBzZWxmLnN0b3BOdW0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcnJheVBvcysrO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmFycmF5UG9zID09PSBzZWxmLnN0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmFycmF5UG9zID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2h1ZmZsZSBzZXF1ZW5jZSBhZ2FpblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZi5zaHVmZmxlKSBzZWxmLnNlcXVlbmNlID0gc2VsZi5zaHVmZmxlQXJyYXkoc2VsZi5zZXF1ZW5jZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZXdyaXRlKHNlbGYuc3RyaW5nc1tzZWxmLnNlcXVlbmNlW3NlbGYuYXJyYXlQb3NdXSwgY3VyU3RyUG9zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBodW1hbml6ZWQgdmFsdWUgZm9yIHR5cGluZ1xuICAgICAgICAgICAgfSwgaHVtYW5pemUpO1xuXG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNodWZmbGVzIHRoZSBudW1iZXJzIGluIHRoZSBnaXZlbiBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAgICAgICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgLHNodWZmbGVBcnJheTogZnVuY3Rpb24oYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciB0bXAsIGN1cnJlbnQsIHRvcCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmKHRvcCkgd2hpbGUoLS10b3ApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKHRvcCArIDEpKTtcbiAgICAgICAgICAgICAgICB0bXAgPSBhcnJheVtjdXJyZW50XTtcbiAgICAgICAgICAgICAgICBhcnJheVtjdXJyZW50XSA9IGFycmF5W3RvcF07XG4gICAgICAgICAgICAgICAgYXJyYXlbdG9wXSA9IHRtcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0ICYgU3RvcCBjdXJyZW50bHkgbm90IHdvcmtpbmdcblxuICAgICAgICAvLyAsIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIC8vICAgICBzZWxmLnN0b3AgPSB0cnVlO1xuICAgICAgICAvLyAgICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVvdXQpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gLCBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vICAgICBpZihzZWxmLnN0b3AgPT09IGZhbHNlKVxuICAgICAgICAvLyAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIC8vICAgICB0aGlzLnN0b3AgPSBmYWxzZTtcbiAgICAgICAgLy8gICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gUmVzZXQgYW5kIHJlYnVpbGQgdGhlIGVsZW1lbnRcbiAgICAgICAgLFxuICAgICAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHNlbGYudGltZW91dCk7XG4gICAgICAgICAgICB2YXIgaWQgPSB0aGlzLmVsLmF0dHIoJ2lkJyk7XG4gICAgICAgICAgICB0aGlzLmVsLmFmdGVyKCc8c3BhbiBpZD1cIicgKyBpZCArICdcIi8+JylcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuY3Vyc29yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIHNlbGYub3B0aW9ucy5yZXNldENhbGxiYWNrKCk7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICAkLmZuLnR5cGVkID0gZnVuY3Rpb24ob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKCd0eXBlZCcpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2Ygb3B0aW9uID09ICdvYmplY3QnICYmIG9wdGlvbjtcbiAgICAgICAgICAgIGlmICghZGF0YSkgJHRoaXMuZGF0YSgndHlwZWQnLCAoZGF0YSA9IG5ldyBUeXBlZCh0aGlzLCBvcHRpb25zKSkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJC5mbi50eXBlZC5kZWZhdWx0cyA9IHtcbiAgICAgICAgc3RyaW5nczogW1wiVGhlc2UgYXJlIHRoZSBkZWZhdWx0IHZhbHVlcy4uLlwiLCBcIllvdSBrbm93IHdoYXQgeW91IHNob3VsZCBkbz9cIiwgXCJVc2UgeW91ciBvd24hXCIsIFwiSGF2ZSBhIGdyZWF0IGRheSFcIl0sXG4gICAgICAgIC8vIHR5cGluZyBzcGVlZFxuICAgICAgICB0eXBlU3BlZWQ6IDAsXG4gICAgICAgIC8vIHRpbWUgYmVmb3JlIHR5cGluZyBzdGFydHNcbiAgICAgICAgc3RhcnREZWxheTogMCxcbiAgICAgICAgLy8gYmFja3NwYWNpbmcgc3BlZWRcbiAgICAgICAgYmFja1NwZWVkOiAwLFxuICAgICAgICAvLyBzaHVmZmxlIHRoZSBzdHJpbmdzXG4gICAgICAgIHNodWZmbGU6IGZhbHNlLFxuICAgICAgICAvLyB0aW1lIGJlZm9yZSBiYWNrc3BhY2luZ1xuICAgICAgICBiYWNrRGVsYXk6IDUwMCxcbiAgICAgICAgLy8gbG9vcFxuICAgICAgICBsb29wOiBmYWxzZSxcbiAgICAgICAgLy8gZmFsc2UgPSBpbmZpbml0ZVxuICAgICAgICBsb29wQ291bnQ6IGZhbHNlLFxuICAgICAgICAvLyBzaG93IGN1cnNvclxuICAgICAgICBzaG93Q3Vyc29yOiB0cnVlLFxuICAgICAgICAvLyBjaGFyYWN0ZXIgZm9yIGN1cnNvclxuICAgICAgICBjdXJzb3JDaGFyOiBcInxcIixcbiAgICAgICAgLy8gYXR0cmlidXRlIHRvIHR5cGUgKG51bGwgPT0gdGV4dClcbiAgICAgICAgYXR0cjogbnVsbCxcbiAgICAgICAgLy8gZWl0aGVyIGh0bWwgb3IgdGV4dFxuICAgICAgICBjb250ZW50VHlwZTogJ2h0bWwnLFxuICAgICAgICAvLyBjYWxsIHdoZW4gZG9uZSBjYWxsYmFjayBmdW5jdGlvblxuICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgLy8gc3RhcnRpbmcgY2FsbGJhY2sgZnVuY3Rpb24gYmVmb3JlIGVhY2ggc3RyaW5nXG4gICAgICAgIHByZVN0cmluZ1R5cGVkOiBmdW5jdGlvbigpIHt9LFxuICAgICAgICAvL2NhbGxiYWNrIGZvciBldmVyeSB0eXBlZCBzdHJpbmdcbiAgICAgICAgb25TdHJpbmdUeXBlZDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgLy8gY2FsbGJhY2sgZm9yIHJlc2V0XG4gICAgICAgIHJlc2V0Q2FsbGJhY2s6IGZ1bmN0aW9uKCkge31cbiAgICB9O1xuXG5cbn0od2luZG93LmpRdWVyeSk7XG4iLCI7KGZ1bmN0aW9uKCl7XHJcbiAgdmFyIG1haW5Nb2R1bGUgPSB7fTtcclxuXHJcbiAgcHVibGljTWV0aG9kKCk7XHJcbiAgaW5pdCgpO1xyXG4gIGF0dGFjaEV2ZW50cygpO1xyXG5cclxuICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgICQoJy5pbnRyb19fdGV4dDEnKS50eXBlZCh7XHJcbiAgICAgICAgc3RyaW5nczogW1wiSSdtIEFudG9uIFBvdnp1bi5cIl0sXHJcbiAgICAgICAgdHlwZVNwZWVkOiA1MCxcclxuICAgICAgICBzaG93Q3Vyc29yOiBmYWxzZSxcclxuICAgICAgICBjYWxsYmFjazogaW50cm9UZXh0MlxyXG4gICAgIH0pO1xyXG4gICAgIFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcclxuICAgIFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGludHJvVGV4dDIoKSB7XHJcbiAgICAkKCcuaW50cm9fX3RleHQyJykudHlwZWQoe1xyXG4gICAgICAgIHN0cmluZ3M6IFtcIkEgcm9ib3QgZnJvbSB0aGUgZnV0dXJlXCIsIFwiQSBmcm9udC1lbmQgZGV2ZWxvcGVyIFwiXSxcclxuICAgICAgICB0eXBlU3BlZWQ6IDUwLFxyXG4gICAgICAgIGJhY2tEZWxheTogNzAwLFxyXG4gICAgICAgIHNob3dDdXJzb3I6IGZhbHNlLFxyXG4gICAgICAgIGNhbGxiYWNrOiBpbnRyb1RleHQzXHJcbiAgICAgfSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gaW50cm9UZXh0MygpIHtcclxuICAgICQoJy5pbnRyb19fdGV4dDMnKS50eXBlZCh7XHJcbiAgICAgICAgc3RyaW5nczogW1wiSSBsaWtlIHRvIG1ha2UgY29vbCBzdHVmZi5cIl0sXHJcbiAgICAgICAgc2hvd0N1cnNvcjogZmFsc2UsXHJcbiAgICAgICAgdHlwZVNwZWVkOiA1MFxyXG4gICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHB1YmxpY01ldGhvZCgpIHtcclxuICAgIG1haW5Nb2R1bGUgPSB7XHJcbiAgICAgIFxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHdpbmRvdy5tYWluTW9kdWxlID0gbWFpbk1vZHVsZTtcclxufSkoKTtcclxuIiwidmFyIHR5cGUgPSByZXF1aXJlKCcuLi9ib3dlci90eXBlZC5qcy9qcy90eXBlZC5qcycpO1xyXG52YXIgbWFpbiA9IHJlcXVpcmUoJy4vX21vZHVsZXMvbWFpbi5qcycpOyJdfQ==
