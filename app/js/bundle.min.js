(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// The MIT License (MIT)

// Typed.js | Copyright (c) 2014 Matt Boldt | www.mattboldt.com

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




! function($) {

    "use strict";

    var Typed = function(el, options) {

        // chosen element to manipulate text
        this.el = $(el);

        // options
        this.options = $.extend({}, $.fn.typed.defaults, options);

        // attribute to type into
        this.isInput = this.el.is('input');
        this.attr = this.options.attr;

        // show cursor
        this.showCursor = this.isInput ? false : this.options.showCursor;

        // text content of element
        this.elContent = this.attr ? this.el.attr(this.attr) : this.el.text()

        // html or plain text
        this.contentType = this.options.contentType;

        // typing speed
        this.typeSpeed = this.options.typeSpeed;

        // add a delay before typing starts
        this.startDelay = this.options.startDelay;

        // backspacing speed
        this.backSpeed = this.options.backSpeed;

        // amount of time to wait before backspacing
        this.backDelay = this.options.backDelay;

        // input strings of text
        this.strings = this.options.strings;

        // character number position of current string
        this.strPos = 0;

        // current array position
        this.arrayPos = 0;

        // number to stop backspacing on.
        // default 0, can change depending on how many chars
        // you want to remove at the time
        this.stopNum = 0;

        // Looping logic
        this.loop = this.options.loop;
        this.loopCount = this.options.loopCount;
        this.curLoop = 0;

        // for stopping
        this.stop = false;

        // custom cursor
        this.cursorChar = this.options.cursorChar;

        // shuffle the strings
        this.shuffle = this.options.shuffle;
        // the order of strings
        this.sequence = [];

        // All systems go!
        this.build();
    };

    Typed.prototype = {

        constructor: Typed

        ,
        init: function() {
            // begin the loop w/ first current string (global self.string)
            // current string will be passed as an argument each time after this
            var self = this;
            self.timeout = setTimeout(function() {
                for (var i=0;i<self.strings.length;++i) self.sequence[i]=i;

                // shuffle the array if true
                if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);

                // Start typing
                self.typewrite(self.strings[self.sequence[self.arrayPos]], self.strPos);
            }, self.startDelay);
        }

        ,
        build: function() {
            // Insert cursor
            if (this.showCursor === true) {
                this.cursor = $("<span class=\"typed-cursor\">" + this.cursorChar + "</span>");
                this.el.after(this.cursor);
            }
            this.init();
        }

        // pass current string state to each function, types 1 char per call
        ,
        typewrite: function(curString, curStrPos) {
            // exit when stopped
            if (this.stop === true) {
                return;
            }

            // varying values for setTimeout during typing
            // can't be global since number changes each time loop is executed
            var humanize = Math.round(Math.random() * (100 - 30)) + this.typeSpeed;
            var self = this;

            // ------------- optional ------------- //
            // backpaces a certain string faster
            // ------------------------------------ //
            // if (self.arrayPos == 1){
            //  self.backDelay = 50;
            // }
            // else{ self.backDelay = 500; }

            // contain typing function in a timeout humanize'd delay
            self.timeout = setTimeout(function() {
                // check for an escape character before a pause value
                // format: \^\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^
                // single ^ are removed from string
                var charPause = 0;
                var substr = curString.substr(curStrPos);
                if (substr.charAt(0) === '^') {
                    var skip = 1; // skip atleast 1
                    if (/^\^\d+/.test(substr)) {
                        substr = /\d+/.exec(substr)[0];
                        skip += substr.length;
                        charPause = parseInt(substr);
                    }

                    // strip out the escape character and pause value so they're not printed
                    curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);
                }

                if (self.contentType === 'html') {
                    // skip over html tags while typing
                    var curChar = curString.substr(curStrPos).charAt(0)
                    if (curChar === '<' || curChar === '&') {
                        var tag = '';
                        var endTag = '';
                        if (curChar === '<') {
                            endTag = '>'
                        } else {
                            endTag = ';'
                        }
                        while (curString.substr(curStrPos).charAt(0) !== endTag) {
                            tag += curString.substr(curStrPos).charAt(0);
                            curStrPos++;
                        }
                        curStrPos++;
                        tag += endTag;
                    }
                }

                // timeout for any pause after a character
                self.timeout = setTimeout(function() {
                    if (curStrPos === curString.length) {
                        // fires callback function
                        self.options.onStringTyped(self.arrayPos);

                        // is this the final string
                        if (self.arrayPos === self.strings.length - 1) {
                            // animation that occurs on the last typed string
                            self.options.callback();

                            self.curLoop++;

                            // quit if we wont loop back
                            if (self.loop === false || self.curLoop === self.loopCount)
                                return;
                        }

                        self.timeout = setTimeout(function() {
                            self.backspace(curString, curStrPos);
                        }, self.backDelay);
                    } else {

                        /* call before functions if applicable */
                        if (curStrPos === 0)
                            self.options.preStringTyped(self.arrayPos);

                        // start typing each new char into existing string
                        // curString: arg, self.el.html: original text inside element
                        var nextString = curString.substr(0, curStrPos + 1);
                        if (self.attr) {
                            self.el.attr(self.attr, nextString);
                        } else {
                            if (self.isInput) {
                                self.el.val(nextString);
                            } else if (self.contentType === 'html') {
                                self.el.html(nextString);
                            } else {
                                self.el.text(nextString);
                            }
                        }

                        // add characters one by one
                        curStrPos++;
                        // loop the function
                        self.typewrite(curString, curStrPos);
                    }
                    // end of character pause
                }, charPause);

                // humanized value for typing
            }, humanize);

        }

        ,
        backspace: function(curString, curStrPos) {
            // exit when stopped
            if (this.stop === true) {
                return;
            }

            // varying values for setTimeout during typing
            // can't be global since number changes each time loop is executed
            var humanize = Math.round(Math.random() * (100 - 30)) + this.backSpeed;
            var self = this;

            self.timeout = setTimeout(function() {

                // ----- this part is optional ----- //
                // check string array position
                // on the first string, only delete one word
                // the stopNum actually represents the amount of chars to
                // keep in the current string. In my case it's 14.
                // if (self.arrayPos == 1){
                //  self.stopNum = 14;
                // }
                //every other time, delete the whole typed string
                // else{
                //  self.stopNum = 0;
                // }

                if (self.contentType === 'html') {
                    // skip over html tags while backspacing
                    if (curString.substr(curStrPos).charAt(0) === '>') {
                        var tag = '';
                        while (curString.substr(curStrPos).charAt(0) !== '<') {
                            tag -= curString.substr(curStrPos).charAt(0);
                            curStrPos--;
                        }
                        curStrPos--;
                        tag += '<';
                    }
                }

                // ----- continue important stuff ----- //
                // replace text with base text + typed characters
                var nextString = curString.substr(0, curStrPos);
                if (self.attr) {
                    self.el.attr(self.attr, nextString);
                } else {
                    if (self.isInput) {
                        self.el.val(nextString);
                    } else if (self.contentType === 'html') {
                        self.el.html(nextString);
                    } else {
                        self.el.text(nextString);
                    }
                }

                // if the number (id of character in current string) is
                // less than the stop number, keep going
                if (curStrPos > self.stopNum) {
                    // subtract characters one by one
                    curStrPos--;
                    // loop the function
                    self.backspace(curString, curStrPos);
                }
                // if the stop number has been reached, increase
                // array position to next string
                else if (curStrPos <= self.stopNum) {
                    self.arrayPos++;

                    if (self.arrayPos === self.strings.length) {
                        self.arrayPos = 0;

                        // Shuffle sequence again
                        if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);

                        self.init();
                    } else
                        self.typewrite(self.strings[self.sequence[self.arrayPos]], curStrPos);
                }

                // humanized value for typing
            }, humanize);

        }
        /**
         * Shuffles the numbers in the given array.
         * @param {Array} array
         * @returns {Array}
         */
        ,shuffleArray: function(array) {
            var tmp, current, top = array.length;
            if(top) while(--top) {
                current = Math.floor(Math.random() * (top + 1));
                tmp = array[current];
                array[current] = array[top];
                array[top] = tmp;
            }
            return array;
        }

        // Start & Stop currently not working

        // , stop: function() {
        //     var self = this;

        //     self.stop = true;
        //     clearInterval(self.timeout);
        // }

        // , start: function() {
        //     var self = this;
        //     if(self.stop === false)
        //        return;

        //     this.stop = false;
        //     this.init();
        // }

        // Reset and rebuild the element
        ,
        reset: function() {
            var self = this;
            clearInterval(self.timeout);
            var id = this.el.attr('id');
            this.el.after('<span id="' + id + '"/>')
            this.el.remove();
            if (typeof this.cursor !== 'undefined') {
                this.cursor.remove();
            }
            // Send the callback
            self.options.resetCallback();
        }

    };

    $.fn.typed = function(option) {
        return this.each(function() {
            var $this = $(this),
                data = $this.data('typed'),
                options = typeof option == 'object' && option;
            if (!data) $this.data('typed', (data = new Typed(this, options)));
            if (typeof option == 'string') data[option]();
        });
    };

    $.fn.typed.defaults = {
        strings: ["These are the default values...", "You know what you should do?", "Use your own!", "Have a great day!"],
        // typing speed
        typeSpeed: 0,
        // time before typing starts
        startDelay: 0,
        // backspacing speed
        backSpeed: 0,
        // shuffle the strings
        shuffle: false,
        // time before backspacing
        backDelay: 500,
        // loop
        loop: false,
        // false = infinite
        loopCount: false,
        // show cursor
        showCursor: true,
        // character for cursor
        cursorChar: "|",
        // attribute to type (null == text)
        attr: null,
        // either html or text
        contentType: 'html',
        // call when done callback function
        callback: function() {},
        // starting callback function before each string
        preStringTyped: function() {},
        //callback for every typed string
        onStringTyped: function() {},
        // callback for reset
        resetCallback: function() {}
    };


}(window.jQuery);

},{}],2:[function(require,module,exports){
;(function() {
  var formModule = {},
      form = $('.form'),
      fields = form.find('input, textarea');

  publicMethod();
  init();
  attachEvents();

  function init() {
    
  };

  function attachEvents() {
    form.on('submit', submitForm)
    fields.on('keydown', hideTooltip);
    form.on('reset', resetForm);
  };

  function submitForm(e) {
    e.preventDefault();

    var data = form.serialize(),
        url = '//php/form.php',
        valid = true;

    $.each(fields, function(index, domElement) {
      var elem = $(domElement),
          that = $(this),
          value = elem.val(),
          trimedValue = $.trim(value),
          fieldParent = that.parent(),
          tooltipTxt = that.attr('data-tooltip');

      if (trimedValue === '') {
        fieldParent.append(
          '<div class="tooltip-wrap">\
            <div class="tooltip">' + tooltipTxt + '</div>\
          </div>');

        that.addClass('empty-field');

        valid = false;
      }
    });

    if (!valid) return false;
    $.ajax({
      url: url,
      type: 'POST',
      data: data
    })
    .done(function() {
      console.log("success");
    })
    .fail(function() {
      console.log("error");
    })
    .always(function() {
      console.log("complete");
    });
    
  };

  /**
   * Hide tips on key down event
   * @param  {object} e Event object
   */
  function hideTooltip(e) {
    var that = $(this),
        tooltip = that.siblings('.tooltip-wrap'),
        content = that.val();
    
    if (e.which > 47 && e.which < 91) {
      that.removeClass('empty-field');
      tooltip.remove();
    }
  };


  function resetForm() {
    var tooltips = form.find('.tooltip-wrap');

    fields.removeClass('empty-field');
    tooltips.remove();
  };

  function publicMethod() {
    formModule = {
      
    }
  };

  window.formModule = formModule;
})();

},{}],3:[function(require,module,exports){
;(function() {
  var mainModule = {},
      toTopBtn = $('#back-to-top');

  publicMethod();
  init();
  attachEvents();

  function init() {
    $('.intro__text1').typed({
      strings: ["I'm Anton Povzun."],
      typeSpeed: 50,
      showCursor: false,
      callback: introText2
    });
  
  };

  function attachEvents() {
    $(window).on('scroll', showToTopBtn);
    toTopBtn.on('click', scrollToTheTop);
    $('nav.menu').on('click', 'a', anchorScroll);
    $(window).on('scroll', scrollCallback);
  };

  function introText2() {
    $('.intro__text2').typed({
      strings: ['A robot from the future', 'A front-end developer '],
      typeSpeed: 50,
      backDelay: 700,
      showCursor: false,
      callback: introText3
     });
  };
  

  function introText3() {
    $('.intro__text3').typed({
      strings: ["I like to make cool stuff."],
      showCursor: false,
      typeSpeed: 50
     });
  };

  function showToTopBtn() {
    var scrollTop = $(window).scrollTop();

    if (scrollTop > 900) {
      toTopBtn.fadeIn(600);
    } else {
      toTopBtn.fadeOut(600);
    }
  };

  function scrollToTheTop(e) {
    e.preventDefault();

    var head = $('#head'),
        top = head.offset().top;

    $('html, body').animate({scrollTop: top}, 700);
  };

  function anchorScroll(e) {
    e.preventDefault();

    var id = $(this).attr('href'),
        top = $(id).offset().top;

    $('html, body').animate({scrollTop: top}, 700);
  };

  function scrollCallback() {
    var item = $('.works__item'),
        itemTop = item.offset().top,
        wScroll = $(window).scrollTop(),
        wHeight = $(window).height(),
        img = $('.intro__img-wrap'),
        imgTop = img.offset().top,
        aboutBlockTop = $('.about__container').offset().top,
        bagBottomEdge = 237;

    /*
     * The appearence of works block
     */
    if (wScroll > itemTop - wHeight / 1.2) {

      item.each(function(i) {
        
        setTimeout(function() {
          item.eq(i).addClass('show');
        },200 * (i+1));

      });
    }

    /*
    * Parallax effects
    */
    if (wScroll > imgTop) {
      // Bag moving
      $('.bag').css({
        'transform': 'translate(0, ' + (wScroll - imgTop) + 'px)'
      });
      if (wScroll > imgTop + bagBottomEdge) {
        $('.bag').css({
          'transform': 'translate(0, ' + bagBottomEdge + 'px)'
        });
      }

      // Boots moving
      $('.boots').css({
        'transform': 'translate(' + -(wScroll - imgTop)/3 + 'px, 0)'
      });

      // Pencil moving
      $('.pencil').css({
        'transform': 'translate(' + (wScroll - imgTop)/11 + 'px, 0)'
      });

      // Phone moving
      $('.phone').css({
        'transform': 'translate(0, ' + -(wScroll - imgTop)/12 + 'px)'
      });
    }

    /*
    * About section floating columns
    */
    if (wScroll > aboutBlockTop - wHeight) {
      var col1 = $('.about__column-1'),
          col2 = $('.about__column-2'),
          offset = Math.min(0, wScroll - aboutBlockTop + wHeight - 500);


      col1.css({
        'transform': 'translate(' + offset + 'px, ' + Math.abs(offset*0.4) + 'px)'
      });

      col2.css({
        'transform': 'translate(' + Math.abs(offset) + 'px, '+ Math.abs(offset*0.4) + 'px)'
      });
    }
  };

  function publicMethod() {
    mainModule = {
      
    }
  };

  window.mainModule = mainModule;
})();

},{}],4:[function(require,module,exports){
;(function() {
  var showcaseModule = {},
      closeBtn = $('#close'),
      work = $('.works__link'),
      showcase = $('#showcase'),
      innerShowcase = $('#inner-showcase'),
      duration = 300,
      shop = {
        imgSrc: './img/shop.jpg',
        title: 'Shop',
        text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit. Tenetur voluptates obcaecati distinctio dignissimos, dicta dolorum molestiae illo numquam, nam, esse minus. Eius magni dolorem fugiat commodi totam, sint illo incidunt?',
        link: 'http://shop.apnweb.ru/',
        figcapture: 'Shop'
      },
      generator = {
        imgSrc: './img/generator.jpg',
        title: 'Generator',
        text: 'Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! ',
        link: 'http://watermark.unostech.ru/',
        figcapture: 'Generator'
      },
      ipadApps = {
        imgSrc: './img/generator.jpg',
        title: 'Ipad Apps',
        text: 'Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! ',
        link: 'http://apps.apnweb.ru/',
        figcapture: 'Ipad Apps'
      },
      ostrov = {
        imgSrc: './img/generator.jpg',
        title: 'Ostrov',
        text: 'Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! Это текст рыба!! ',
        link: 'http://watermark.unostech.ru/',
        figcapture: 'Ostrov'
      };

  publicMethod();
  init();
  attachEvents();

  function init() {
    // Some code..functions that are needed for module initialization 
  };

  function attachEvents() {
    closeBtn.on('click', closeShowcase);
    work.on('click', showShowcase);
  };

  function closeShowcase(e) {
    e.preventDefault();

    innerShowcase.slideUp(duration);
    showcase.fadeOut(duration);
  };

  function showShowcase(e) {
    e.preventDefault();

    var click = $(this),
        img = $('#img'),
        title = $('#title'),
        text = $('#text'),
        link = $('.link'),
        figcapture = $('#figcapture');
    
    if(click.attr('href') === '#shop') {
      addValues(shop);
    }
    else if(click.attr('href') === '#generator') {
      addValues(generator);
    }
    else if(click.attr('href') === '#ostrov') {
      addValues(ostrov);
    }
    else if(click.attr('href') === '#ipadApps') {
      addValues(ipadApps);
    }

    innerShowcase.fadeIn(duration);
    showcase.slideDown(duration);

    $('html, body').animate({scrollTop: showcase.offset().top}, duration)

    function addValues(obj) {
      img.attr('src', obj.imgSrc);
      title.text(obj.title);
      text.text(obj.text);
      link.each(function() {
        link.attr('href', obj.link)
      });
      figcapture.text(obj.figcapture)
    };
  };

  function publicMethod() {
    showcaseModule = {
      // name : public function
    }
  };

  window.showcaseModule = showcaseModule;
})();

},{}],5:[function(require,module,exports){
var type = require('../bower/typed.js/js/typed.js');
var main = require('./_modules/main.js');
var showcase = require('./_modules/showcase.js');
var form = require('./_modules/form.js');

},{"../bower/typed.js/js/typed.js":1,"./_modules/form.js":2,"./_modules/main.js":3,"./_modules/showcase.js":4}]},{},[5])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxPcGVuc2VydmVyXFxkb21haW5zXFxwb3J0Zm9saW9cXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkQ6L09wZW5zZXJ2ZXIvZG9tYWlucy9wb3J0Zm9saW8vYXBwL2Jvd2VyL3R5cGVkLmpzL2pzL3R5cGVkLmpzIiwiRDovT3BlbnNlcnZlci9kb21haW5zL3BvcnRmb2xpby9hcHAvanMvX21vZHVsZXMvZm9ybS5qcyIsIkQ6L09wZW5zZXJ2ZXIvZG9tYWlucy9wb3J0Zm9saW8vYXBwL2pzL19tb2R1bGVzL21haW4uanMiLCJEOi9PcGVuc2VydmVyL2RvbWFpbnMvcG9ydGZvbGlvL2FwcC9qcy9fbW9kdWxlcy9zaG93Y2FzZS5qcyIsIkQ6L09wZW5zZXJ2ZXIvZG9tYWlucy9wb3J0Zm9saW8vYXBwL2pzL2Zha2VfZmE5ZjVmOWMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4vLyBUeXBlZC5qcyB8IENvcHlyaWdodCAoYykgMjAxNCBNYXR0IEJvbGR0IHwgd3d3Lm1hdHRib2xkdC5jb21cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuXG4hIGZ1bmN0aW9uKCQpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIFR5cGVkID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBjaG9zZW4gZWxlbWVudCB0byBtYW5pcHVsYXRlIHRleHRcbiAgICAgICAgdGhpcy5lbCA9ICQoZWwpO1xuXG4gICAgICAgIC8vIG9wdGlvbnNcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4udHlwZWQuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGF0dHJpYnV0ZSB0byB0eXBlIGludG9cbiAgICAgICAgdGhpcy5pc0lucHV0ID0gdGhpcy5lbC5pcygnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5hdHRyID0gdGhpcy5vcHRpb25zLmF0dHI7XG5cbiAgICAgICAgLy8gc2hvdyBjdXJzb3JcbiAgICAgICAgdGhpcy5zaG93Q3Vyc29yID0gdGhpcy5pc0lucHV0ID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2hvd0N1cnNvcjtcblxuICAgICAgICAvLyB0ZXh0IGNvbnRlbnQgb2YgZWxlbWVudFxuICAgICAgICB0aGlzLmVsQ29udGVudCA9IHRoaXMuYXR0ciA/IHRoaXMuZWwuYXR0cih0aGlzLmF0dHIpIDogdGhpcy5lbC50ZXh0KClcblxuICAgICAgICAvLyBodG1sIG9yIHBsYWluIHRleHRcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IHRoaXMub3B0aW9ucy5jb250ZW50VHlwZTtcblxuICAgICAgICAvLyB0eXBpbmcgc3BlZWRcbiAgICAgICAgdGhpcy50eXBlU3BlZWQgPSB0aGlzLm9wdGlvbnMudHlwZVNwZWVkO1xuXG4gICAgICAgIC8vIGFkZCBhIGRlbGF5IGJlZm9yZSB0eXBpbmcgc3RhcnRzXG4gICAgICAgIHRoaXMuc3RhcnREZWxheSA9IHRoaXMub3B0aW9ucy5zdGFydERlbGF5O1xuXG4gICAgICAgIC8vIGJhY2tzcGFjaW5nIHNwZWVkXG4gICAgICAgIHRoaXMuYmFja1NwZWVkID0gdGhpcy5vcHRpb25zLmJhY2tTcGVlZDtcblxuICAgICAgICAvLyBhbW91bnQgb2YgdGltZSB0byB3YWl0IGJlZm9yZSBiYWNrc3BhY2luZ1xuICAgICAgICB0aGlzLmJhY2tEZWxheSA9IHRoaXMub3B0aW9ucy5iYWNrRGVsYXk7XG5cbiAgICAgICAgLy8gaW5wdXQgc3RyaW5ncyBvZiB0ZXh0XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHRoaXMub3B0aW9ucy5zdHJpbmdzO1xuXG4gICAgICAgIC8vIGNoYXJhY3RlciBudW1iZXIgcG9zaXRpb24gb2YgY3VycmVudCBzdHJpbmdcbiAgICAgICAgdGhpcy5zdHJQb3MgPSAwO1xuXG4gICAgICAgIC8vIGN1cnJlbnQgYXJyYXkgcG9zaXRpb25cbiAgICAgICAgdGhpcy5hcnJheVBvcyA9IDA7XG5cbiAgICAgICAgLy8gbnVtYmVyIHRvIHN0b3AgYmFja3NwYWNpbmcgb24uXG4gICAgICAgIC8vIGRlZmF1bHQgMCwgY2FuIGNoYW5nZSBkZXBlbmRpbmcgb24gaG93IG1hbnkgY2hhcnNcbiAgICAgICAgLy8geW91IHdhbnQgdG8gcmVtb3ZlIGF0IHRoZSB0aW1lXG4gICAgICAgIHRoaXMuc3RvcE51bSA9IDA7XG5cbiAgICAgICAgLy8gTG9vcGluZyBsb2dpY1xuICAgICAgICB0aGlzLmxvb3AgPSB0aGlzLm9wdGlvbnMubG9vcDtcbiAgICAgICAgdGhpcy5sb29wQ291bnQgPSB0aGlzLm9wdGlvbnMubG9vcENvdW50O1xuICAgICAgICB0aGlzLmN1ckxvb3AgPSAwO1xuXG4gICAgICAgIC8vIGZvciBzdG9wcGluZ1xuICAgICAgICB0aGlzLnN0b3AgPSBmYWxzZTtcblxuICAgICAgICAvLyBjdXN0b20gY3Vyc29yXG4gICAgICAgIHRoaXMuY3Vyc29yQ2hhciA9IHRoaXMub3B0aW9ucy5jdXJzb3JDaGFyO1xuXG4gICAgICAgIC8vIHNodWZmbGUgdGhlIHN0cmluZ3NcbiAgICAgICAgdGhpcy5zaHVmZmxlID0gdGhpcy5vcHRpb25zLnNodWZmbGU7XG4gICAgICAgIC8vIHRoZSBvcmRlciBvZiBzdHJpbmdzXG4gICAgICAgIHRoaXMuc2VxdWVuY2UgPSBbXTtcblxuICAgICAgICAvLyBBbGwgc3lzdGVtcyBnbyFcbiAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH07XG5cbiAgICBUeXBlZC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFR5cGVkXG5cbiAgICAgICAgLFxuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGJlZ2luIHRoZSBsb29wIHcvIGZpcnN0IGN1cnJlbnQgc3RyaW5nIChnbG9iYWwgc2VsZi5zdHJpbmcpXG4gICAgICAgICAgICAvLyBjdXJyZW50IHN0cmluZyB3aWxsIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudCBlYWNoIHRpbWUgYWZ0ZXIgdGhpc1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7aTxzZWxmLnN0cmluZ3MubGVuZ3RoOysraSkgc2VsZi5zZXF1ZW5jZVtpXT1pO1xuXG4gICAgICAgICAgICAgICAgLy8gc2h1ZmZsZSB0aGUgYXJyYXkgaWYgdHJ1ZVxuICAgICAgICAgICAgICAgIGlmKHNlbGYuc2h1ZmZsZSkgc2VsZi5zZXF1ZW5jZSA9IHNlbGYuc2h1ZmZsZUFycmF5KHNlbGYuc2VxdWVuY2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdHlwaW5nXG4gICAgICAgICAgICAgICAgc2VsZi50eXBld3JpdGUoc2VsZi5zdHJpbmdzW3NlbGYuc2VxdWVuY2Vbc2VsZi5hcnJheVBvc11dLCBzZWxmLnN0clBvcyk7XG4gICAgICAgICAgICB9LCBzZWxmLnN0YXJ0RGVsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLFxuICAgICAgICBidWlsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgY3Vyc29yXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93Q3Vyc29yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAkKFwiPHNwYW4gY2xhc3M9XFxcInR5cGVkLWN1cnNvclxcXCI+XCIgKyB0aGlzLmN1cnNvckNoYXIgKyBcIjwvc3Bhbj5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hZnRlcih0aGlzLmN1cnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhc3MgY3VycmVudCBzdHJpbmcgc3RhdGUgdG8gZWFjaCBmdW5jdGlvbiwgdHlwZXMgMSBjaGFyIHBlciBjYWxsXG4gICAgICAgICxcbiAgICAgICAgdHlwZXdyaXRlOiBmdW5jdGlvbihjdXJTdHJpbmcsIGN1clN0clBvcykge1xuICAgICAgICAgICAgLy8gZXhpdCB3aGVuIHN0b3BwZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhcnlpbmcgdmFsdWVzIGZvciBzZXRUaW1lb3V0IGR1cmluZyB0eXBpbmdcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIGdsb2JhbCBzaW5jZSBudW1iZXIgY2hhbmdlcyBlYWNoIHRpbWUgbG9vcCBpcyBleGVjdXRlZFxuICAgICAgICAgICAgdmFyIGh1bWFuaXplID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDEwMCAtIDMwKSkgKyB0aGlzLnR5cGVTcGVlZDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBvcHRpb25hbCAtLS0tLS0tLS0tLS0tIC8vXG4gICAgICAgICAgICAvLyBiYWNrcGFjZXMgYSBjZXJ0YWluIHN0cmluZyBmYXN0ZXJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAgICAgLy8gaWYgKHNlbGYuYXJyYXlQb3MgPT0gMSl7XG4gICAgICAgICAgICAvLyAgc2VsZi5iYWNrRGVsYXkgPSA1MDtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGVsc2V7IHNlbGYuYmFja0RlbGF5ID0gNTAwOyB9XG5cbiAgICAgICAgICAgIC8vIGNvbnRhaW4gdHlwaW5nIGZ1bmN0aW9uIGluIGEgdGltZW91dCBodW1hbml6ZSdkIGRlbGF5XG4gICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhbiBlc2NhcGUgY2hhcmFjdGVyIGJlZm9yZSBhIHBhdXNlIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gZm9ybWF0OiBcXF5cXGQrIC4uIGVnOiBeMTAwMCAuLiBzaG91bGQgYmUgYWJsZSB0byBwcmludCB0aGUgXiB0b28gdXNpbmcgXl5cbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgXiBhcmUgcmVtb3ZlZCBmcm9tIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBjaGFyUGF1c2UgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdHIgPSBjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnN0ci5jaGFyQXQoMCkgPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcCA9IDE7IC8vIHNraXAgYXRsZWFzdCAxXG4gICAgICAgICAgICAgICAgICAgIGlmICgvXlxcXlxcZCsvLnRlc3Qoc3Vic3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyID0gL1xcZCsvLmV4ZWMoc3Vic3RyKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgKz0gc3Vic3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJQYXVzZSA9IHBhcnNlSW50KHN1YnN0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCBvdXQgdGhlIGVzY2FwZSBjaGFyYWN0ZXIgYW5kIHBhdXNlIHZhbHVlIHNvIHRoZXkncmUgbm90IHByaW50ZWRcbiAgICAgICAgICAgICAgICAgICAgY3VyU3RyaW5nID0gY3VyU3RyaW5nLnN1YnN0cmluZygwLCBjdXJTdHJQb3MpICsgY3VyU3RyaW5nLnN1YnN0cmluZyhjdXJTdHJQb3MgKyBza2lwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb250ZW50VHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgb3ZlciBodG1sIHRhZ3Mgd2hpbGUgdHlwaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJDaGFyID0gY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hhciA9PT0gJzwnIHx8IGN1ckNoYXIgPT09ICcmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFRhZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoYXIgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRhZyA9ICc+J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRUYWcgPSAnOydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcykuY2hhckF0KDApICE9PSBlbmRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgKz0gY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJTdHJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clN0clBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnICs9IGVuZFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRpbWVvdXQgZm9yIGFueSBwYXVzZSBhZnRlciBhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJTdHJQb3MgPT09IGN1clN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmVzIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMub25TdHJpbmdUeXBlZChzZWxmLmFycmF5UG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhpcyB0aGUgZmluYWwgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcnJheVBvcyA9PT0gc2VsZi5zdHJpbmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gdGhhdCBvY2N1cnMgb24gdGhlIGxhc3QgdHlwZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLmNhbGxiYWNrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1ckxvb3ArKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1aXQgaWYgd2Ugd29udCBsb29wIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sb29wID09PSBmYWxzZSB8fCBzZWxmLmN1ckxvb3AgPT09IHNlbGYubG9vcENvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iYWNrc3BhY2UoY3VyU3RyaW5nLCBjdXJTdHJQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VsZi5iYWNrRGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjYWxsIGJlZm9yZSBmdW5jdGlvbnMgaWYgYXBwbGljYWJsZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clN0clBvcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMucHJlU3RyaW5nVHlwZWQoc2VsZi5hcnJheVBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHR5cGluZyBlYWNoIG5ldyBjaGFyIGludG8gZXhpc3Rpbmcgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJTdHJpbmc6IGFyZywgc2VsZi5lbC5odG1sOiBvcmlnaW5hbCB0ZXh0IGluc2lkZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0cmluZyA9IGN1clN0cmluZy5zdWJzdHIoMCwgY3VyU3RyUG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC5hdHRyKHNlbGYuYXR0ciwgbmV4dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC52YWwobmV4dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC5odG1sKG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWwudGV4dChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBjaGFyYWN0ZXJzIG9uZSBieSBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clN0clBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZXdyaXRlKGN1clN0cmluZywgY3VyU3RyUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgb2YgY2hhcmFjdGVyIHBhdXNlXG4gICAgICAgICAgICAgICAgfSwgY2hhclBhdXNlKTtcblxuICAgICAgICAgICAgICAgIC8vIGh1bWFuaXplZCB2YWx1ZSBmb3IgdHlwaW5nXG4gICAgICAgICAgICB9LCBodW1hbml6ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgICxcbiAgICAgICAgYmFja3NwYWNlOiBmdW5jdGlvbihjdXJTdHJpbmcsIGN1clN0clBvcykge1xuICAgICAgICAgICAgLy8gZXhpdCB3aGVuIHN0b3BwZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhcnlpbmcgdmFsdWVzIGZvciBzZXRUaW1lb3V0IGR1cmluZyB0eXBpbmdcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIGdsb2JhbCBzaW5jZSBudW1iZXIgY2hhbmdlcyBlYWNoIHRpbWUgbG9vcCBpcyBleGVjdXRlZFxuICAgICAgICAgICAgdmFyIGh1bWFuaXplID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDEwMCAtIDMwKSkgKyB0aGlzLmJhY2tTcGVlZDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIC0tLS0tIHRoaXMgcGFydCBpcyBvcHRpb25hbCAtLS0tLSAvL1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHN0cmluZyBhcnJheSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBmaXJzdCBzdHJpbmcsIG9ubHkgZGVsZXRlIG9uZSB3b3JkXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0b3BOdW0gYWN0dWFsbHkgcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGNoYXJzIHRvXG4gICAgICAgICAgICAgICAgLy8ga2VlcCBpbiB0aGUgY3VycmVudCBzdHJpbmcuIEluIG15IGNhc2UgaXQncyAxNC5cbiAgICAgICAgICAgICAgICAvLyBpZiAoc2VsZi5hcnJheVBvcyA9PSAxKXtcbiAgICAgICAgICAgICAgICAvLyAgc2VsZi5zdG9wTnVtID0gMTQ7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vZXZlcnkgb3RoZXIgdGltZSwgZGVsZXRlIHRoZSB3aG9sZSB0eXBlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBlbHNle1xuICAgICAgICAgICAgICAgIC8vICBzZWxmLnN0b3BOdW0gPSAwO1xuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBvdmVyIGh0bWwgdGFncyB3aGlsZSBiYWNrc3BhY2luZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKSAhPT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIC09IGN1clN0cmluZy5zdWJzdHIoY3VyU3RyUG9zKS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyU3RyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTdHJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArPSAnPCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAtLS0tLSBjb250aW51ZSBpbXBvcnRhbnQgc3R1ZmYgLS0tLS0gLy9cbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRleHQgd2l0aCBiYXNlIHRleHQgKyB0eXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdHJpbmcgPSBjdXJTdHJpbmcuc3Vic3RyKDAsIGN1clN0clBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVsLmF0dHIoc2VsZi5hdHRyLCBuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsLnZhbChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWwuaHRtbChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWwudGV4dChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBudW1iZXIgKGlkIG9mIGNoYXJhY3RlciBpbiBjdXJyZW50IHN0cmluZykgaXNcbiAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHN0b3AgbnVtYmVyLCBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgaWYgKGN1clN0clBvcyA+IHNlbGYuc3RvcE51bSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCBjaGFyYWN0ZXJzIG9uZSBieSBvbmVcbiAgICAgICAgICAgICAgICAgICAgY3VyU3RyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmFja3NwYWNlKGN1clN0cmluZywgY3VyU3RyUG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0b3AgbnVtYmVyIGhhcyBiZWVuIHJlYWNoZWQsIGluY3JlYXNlXG4gICAgICAgICAgICAgICAgLy8gYXJyYXkgcG9zaXRpb24gdG8gbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJTdHJQb3MgPD0gc2VsZi5zdG9wTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJyYXlQb3MrKztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcnJheVBvcyA9PT0gc2VsZi5zdHJpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcnJheVBvcyA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodWZmbGUgc2VxdWVuY2UgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGYuc2h1ZmZsZSkgc2VsZi5zZXF1ZW5jZSA9IHNlbGYuc2h1ZmZsZUFycmF5KHNlbGYuc2VxdWVuY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnR5cGV3cml0ZShzZWxmLnN0cmluZ3Nbc2VsZi5zZXF1ZW5jZVtzZWxmLmFycmF5UG9zXV0sIGN1clN0clBvcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaHVtYW5pemVkIHZhbHVlIGZvciB0eXBpbmdcbiAgICAgICAgICAgIH0sIGh1bWFuaXplKTtcblxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaHVmZmxlcyB0aGUgbnVtYmVycyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgICxzaHVmZmxlQXJyYXk6IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgdG1wLCBjdXJyZW50LCB0b3AgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBpZih0b3ApIHdoaWxlKC0tdG9wKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0b3AgKyAxKSk7XG4gICAgICAgICAgICAgICAgdG1wID0gYXJyYXlbY3VycmVudF07XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VycmVudF0gPSBhcnJheVt0b3BdO1xuICAgICAgICAgICAgICAgIGFycmF5W3RvcF0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCAmIFN0b3AgY3VycmVudGx5IG5vdCB3b3JraW5nXG5cbiAgICAgICAgLy8gLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyAgICAgc2VsZi5zdG9wID0gdHJ1ZTtcbiAgICAgICAgLy8gICAgIGNsZWFySW50ZXJ2YWwoc2VsZi50aW1lb3V0KTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vICwgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvLyAgICAgaWYoc2VsZi5zdG9wID09PSBmYWxzZSlcbiAgICAgICAgLy8gICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyAgICAgdGhpcy5zdG9wID0gZmFsc2U7XG4gICAgICAgIC8vICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIFJlc2V0IGFuZCByZWJ1aWxkIHRoZSBlbGVtZW50XG4gICAgICAgICxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVvdXQpO1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5lbC5hdHRyKCdpZCcpO1xuICAgICAgICAgICAgdGhpcy5lbC5hZnRlcignPHNwYW4gaWQ9XCInICsgaWQgKyAnXCIvPicpXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmN1cnNvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMucmVzZXRDYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgJC5mbi50eXBlZCA9IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgndHlwZWQnKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb247XG4gICAgICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ3R5cGVkJywgKGRhdGEgPSBuZXcgVHlwZWQodGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICQuZm4udHlwZWQuZGVmYXVsdHMgPSB7XG4gICAgICAgIHN0cmluZ3M6IFtcIlRoZXNlIGFyZSB0aGUgZGVmYXVsdCB2YWx1ZXMuLi5cIiwgXCJZb3Uga25vdyB3aGF0IHlvdSBzaG91bGQgZG8/XCIsIFwiVXNlIHlvdXIgb3duIVwiLCBcIkhhdmUgYSBncmVhdCBkYXkhXCJdLFxuICAgICAgICAvLyB0eXBpbmcgc3BlZWRcbiAgICAgICAgdHlwZVNwZWVkOiAwLFxuICAgICAgICAvLyB0aW1lIGJlZm9yZSB0eXBpbmcgc3RhcnRzXG4gICAgICAgIHN0YXJ0RGVsYXk6IDAsXG4gICAgICAgIC8vIGJhY2tzcGFjaW5nIHNwZWVkXG4gICAgICAgIGJhY2tTcGVlZDogMCxcbiAgICAgICAgLy8gc2h1ZmZsZSB0aGUgc3RyaW5nc1xuICAgICAgICBzaHVmZmxlOiBmYWxzZSxcbiAgICAgICAgLy8gdGltZSBiZWZvcmUgYmFja3NwYWNpbmdcbiAgICAgICAgYmFja0RlbGF5OiA1MDAsXG4gICAgICAgIC8vIGxvb3BcbiAgICAgICAgbG9vcDogZmFsc2UsXG4gICAgICAgIC8vIGZhbHNlID0gaW5maW5pdGVcbiAgICAgICAgbG9vcENvdW50OiBmYWxzZSxcbiAgICAgICAgLy8gc2hvdyBjdXJzb3JcbiAgICAgICAgc2hvd0N1cnNvcjogdHJ1ZSxcbiAgICAgICAgLy8gY2hhcmFjdGVyIGZvciBjdXJzb3JcbiAgICAgICAgY3Vyc29yQ2hhcjogXCJ8XCIsXG4gICAgICAgIC8vIGF0dHJpYnV0ZSB0byB0eXBlIChudWxsID09IHRleHQpXG4gICAgICAgIGF0dHI6IG51bGwsXG4gICAgICAgIC8vIGVpdGhlciBodG1sIG9yIHRleHRcbiAgICAgICAgY29udGVudFR5cGU6ICdodG1sJyxcbiAgICAgICAgLy8gY2FsbCB3aGVuIGRvbmUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIC8vIHN0YXJ0aW5nIGNhbGxiYWNrIGZ1bmN0aW9uIGJlZm9yZSBlYWNoIHN0cmluZ1xuICAgICAgICBwcmVTdHJpbmdUeXBlZDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgLy9jYWxsYmFjayBmb3IgZXZlcnkgdHlwZWQgc3RyaW5nXG4gICAgICAgIG9uU3RyaW5nVHlwZWQ6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIC8vIGNhbGxiYWNrIGZvciByZXNldFxuICAgICAgICByZXNldENhbGxiYWNrOiBmdW5jdGlvbigpIHt9XG4gICAgfTtcblxuXG59KHdpbmRvdy5qUXVlcnkpO1xuIiwiOyhmdW5jdGlvbigpIHtcclxuICB2YXIgZm9ybU1vZHVsZSA9IHt9LFxyXG4gICAgICBmb3JtID0gJCgnLmZvcm0nKSxcclxuICAgICAgZmllbGRzID0gZm9ybS5maW5kKCdpbnB1dCwgdGV4dGFyZWEnKTtcclxuXHJcbiAgcHVibGljTWV0aG9kKCk7XHJcbiAgaW5pdCgpO1xyXG4gIGF0dGFjaEV2ZW50cygpO1xyXG5cclxuICBmdW5jdGlvbiBpbml0KCkge1xyXG4gICAgXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gYXR0YWNoRXZlbnRzKCkge1xyXG4gICAgZm9ybS5vbignc3VibWl0Jywgc3VibWl0Rm9ybSlcclxuICAgIGZpZWxkcy5vbigna2V5ZG93bicsIGhpZGVUb29sdGlwKTtcclxuICAgIGZvcm0ub24oJ3Jlc2V0JywgcmVzZXRGb3JtKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBzdWJtaXRGb3JtKGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICB2YXIgZGF0YSA9IGZvcm0uc2VyaWFsaXplKCksXHJcbiAgICAgICAgdXJsID0gJy8vcGhwL2Zvcm0ucGhwJyxcclxuICAgICAgICB2YWxpZCA9IHRydWU7XHJcblxyXG4gICAgJC5lYWNoKGZpZWxkcywgZnVuY3Rpb24oaW5kZXgsIGRvbUVsZW1lbnQpIHtcclxuICAgICAgdmFyIGVsZW0gPSAkKGRvbUVsZW1lbnQpLFxyXG4gICAgICAgICAgdGhhdCA9ICQodGhpcyksXHJcbiAgICAgICAgICB2YWx1ZSA9IGVsZW0udmFsKCksXHJcbiAgICAgICAgICB0cmltZWRWYWx1ZSA9ICQudHJpbSh2YWx1ZSksXHJcbiAgICAgICAgICBmaWVsZFBhcmVudCA9IHRoYXQucGFyZW50KCksXHJcbiAgICAgICAgICB0b29sdGlwVHh0ID0gdGhhdC5hdHRyKCdkYXRhLXRvb2x0aXAnKTtcclxuXHJcbiAgICAgIGlmICh0cmltZWRWYWx1ZSA9PT0gJycpIHtcclxuICAgICAgICBmaWVsZFBhcmVudC5hcHBlbmQoXHJcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2x0aXAtd3JhcFwiPlxcXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJ0b29sdGlwXCI+JyArIHRvb2x0aXBUeHQgKyAnPC9kaXY+XFxcclxuICAgICAgICAgIDwvZGl2PicpO1xyXG5cclxuICAgICAgICB0aGF0LmFkZENsYXNzKCdlbXB0eS1maWVsZCcpO1xyXG5cclxuICAgICAgICB2YWxpZCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXZhbGlkKSByZXR1cm4gZmFsc2U7XHJcbiAgICAkLmFqYXgoe1xyXG4gICAgICB1cmw6IHVybCxcclxuICAgICAgdHlwZTogJ1BPU1QnLFxyXG4gICAgICBkYXRhOiBkYXRhXHJcbiAgICB9KVxyXG4gICAgLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwic3VjY2Vzc1wiKTtcclxuICAgIH0pXHJcbiAgICAuZmFpbChmdW5jdGlvbigpIHtcclxuICAgICAgY29uc29sZS5sb2coXCJlcnJvclwiKTtcclxuICAgIH0pXHJcbiAgICAuYWx3YXlzKGZ1bmN0aW9uKCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhcImNvbXBsZXRlXCIpO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBIaWRlIHRpcHMgb24ga2V5IGRvd24gZXZlbnRcclxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGUgRXZlbnQgb2JqZWN0XHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaGlkZVRvb2x0aXAoZSkge1xyXG4gICAgdmFyIHRoYXQgPSAkKHRoaXMpLFxyXG4gICAgICAgIHRvb2x0aXAgPSB0aGF0LnNpYmxpbmdzKCcudG9vbHRpcC13cmFwJyksXHJcbiAgICAgICAgY29udGVudCA9IHRoYXQudmFsKCk7XHJcbiAgICBcclxuICAgIGlmIChlLndoaWNoID4gNDcgJiYgZS53aGljaCA8IDkxKSB7XHJcbiAgICAgIHRoYXQucmVtb3ZlQ2xhc3MoJ2VtcHR5LWZpZWxkJyk7XHJcbiAgICAgIHRvb2x0aXAucmVtb3ZlKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcblxyXG4gIGZ1bmN0aW9uIHJlc2V0Rm9ybSgpIHtcclxuICAgIHZhciB0b29sdGlwcyA9IGZvcm0uZmluZCgnLnRvb2x0aXAtd3JhcCcpO1xyXG5cclxuICAgIGZpZWxkcy5yZW1vdmVDbGFzcygnZW1wdHktZmllbGQnKTtcclxuICAgIHRvb2x0aXBzLnJlbW92ZSgpO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHB1YmxpY01ldGhvZCgpIHtcclxuICAgIGZvcm1Nb2R1bGUgPSB7XHJcbiAgICAgIFxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHdpbmRvdy5mb3JtTW9kdWxlID0gZm9ybU1vZHVsZTtcclxufSkoKTtcclxuIiwiOyhmdW5jdGlvbigpIHtcbiAgdmFyIG1haW5Nb2R1bGUgPSB7fSxcbiAgICAgIHRvVG9wQnRuID0gJCgnI2JhY2stdG8tdG9wJyk7XG5cbiAgcHVibGljTWV0aG9kKCk7XG4gIGluaXQoKTtcbiAgYXR0YWNoRXZlbnRzKCk7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAkKCcuaW50cm9fX3RleHQxJykudHlwZWQoe1xuICAgICAgc3RyaW5nczogW1wiSSdtIEFudG9uIFBvdnp1bi5cIl0sXG4gICAgICB0eXBlU3BlZWQ6IDUwLFxuICAgICAgc2hvd0N1cnNvcjogZmFsc2UsXG4gICAgICBjYWxsYmFjazogaW50cm9UZXh0MlxuICAgIH0pO1xuICBcbiAgfTtcblxuICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBzaG93VG9Ub3BCdG4pO1xuICAgIHRvVG9wQnRuLm9uKCdjbGljaycsIHNjcm9sbFRvVGhlVG9wKTtcbiAgICAkKCduYXYubWVudScpLm9uKCdjbGljaycsICdhJywgYW5jaG9yU2Nyb2xsKTtcbiAgICAkKHdpbmRvdykub24oJ3Njcm9sbCcsIHNjcm9sbENhbGxiYWNrKTtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnRyb1RleHQyKCkge1xuICAgICQoJy5pbnRyb19fdGV4dDInKS50eXBlZCh7XG4gICAgICBzdHJpbmdzOiBbJ0Egcm9ib3QgZnJvbSB0aGUgZnV0dXJlJywgJ0EgZnJvbnQtZW5kIGRldmVsb3BlciAnXSxcbiAgICAgIHR5cGVTcGVlZDogNTAsXG4gICAgICBiYWNrRGVsYXk6IDcwMCxcbiAgICAgIHNob3dDdXJzb3I6IGZhbHNlLFxuICAgICAgY2FsbGJhY2s6IGludHJvVGV4dDNcbiAgICAgfSk7XG4gIH07XG4gIFxuXG4gIGZ1bmN0aW9uIGludHJvVGV4dDMoKSB7XG4gICAgJCgnLmludHJvX190ZXh0MycpLnR5cGVkKHtcbiAgICAgIHN0cmluZ3M6IFtcIkkgbGlrZSB0byBtYWtlIGNvb2wgc3R1ZmYuXCJdLFxuICAgICAgc2hvd0N1cnNvcjogZmFsc2UsXG4gICAgICB0eXBlU3BlZWQ6IDUwXG4gICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNob3dUb1RvcEJ0bigpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG4gICAgaWYgKHNjcm9sbFRvcCA+IDkwMCkge1xuICAgICAgdG9Ub3BCdG4uZmFkZUluKDYwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvVG9wQnRuLmZhZGVPdXQoNjAwKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc2Nyb2xsVG9UaGVUb3AoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBoZWFkID0gJCgnI2hlYWQnKSxcbiAgICAgICAgdG9wID0gaGVhZC5vZmZzZXQoKS50b3A7XG5cbiAgICAkKCdodG1sLCBib2R5JykuYW5pbWF0ZSh7c2Nyb2xsVG9wOiB0b3B9LCA3MDApO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFuY2hvclNjcm9sbChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgdmFyIGlkID0gJCh0aGlzKS5hdHRyKCdocmVmJyksXG4gICAgICAgIHRvcCA9ICQoaWQpLm9mZnNldCgpLnRvcDtcblxuICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtzY3JvbGxUb3A6IHRvcH0sIDcwMCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc2Nyb2xsQ2FsbGJhY2soKSB7XG4gICAgdmFyIGl0ZW0gPSAkKCcud29ya3NfX2l0ZW0nKSxcbiAgICAgICAgaXRlbVRvcCA9IGl0ZW0ub2Zmc2V0KCkudG9wLFxuICAgICAgICB3U2Nyb2xsID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpLFxuICAgICAgICB3SGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpLFxuICAgICAgICBpbWcgPSAkKCcuaW50cm9fX2ltZy13cmFwJyksXG4gICAgICAgIGltZ1RvcCA9IGltZy5vZmZzZXQoKS50b3AsXG4gICAgICAgIGFib3V0QmxvY2tUb3AgPSAkKCcuYWJvdXRfX2NvbnRhaW5lcicpLm9mZnNldCgpLnRvcCxcbiAgICAgICAgYmFnQm90dG9tRWRnZSA9IDIzNztcblxuICAgIC8qXG4gICAgICogVGhlIGFwcGVhcmVuY2Ugb2Ygd29ya3MgYmxvY2tcbiAgICAgKi9cbiAgICBpZiAod1Njcm9sbCA+IGl0ZW1Ub3AgLSB3SGVpZ2h0IC8gMS4yKSB7XG5cbiAgICAgIGl0ZW0uZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGl0ZW0uZXEoaSkuYWRkQ2xhc3MoJ3Nob3cnKTtcbiAgICAgICAgfSwyMDAgKiAoaSsxKSk7XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qXG4gICAgKiBQYXJhbGxheCBlZmZlY3RzXG4gICAgKi9cbiAgICBpZiAod1Njcm9sbCA+IGltZ1RvcCkge1xuICAgICAgLy8gQmFnIG1vdmluZ1xuICAgICAgJCgnLmJhZycpLmNzcyh7XG4gICAgICAgICd0cmFuc2Zvcm0nOiAndHJhbnNsYXRlKDAsICcgKyAod1Njcm9sbCAtIGltZ1RvcCkgKyAncHgpJ1xuICAgICAgfSk7XG4gICAgICBpZiAod1Njcm9sbCA+IGltZ1RvcCArIGJhZ0JvdHRvbUVkZ2UpIHtcbiAgICAgICAgJCgnLmJhZycpLmNzcyh7XG4gICAgICAgICAgJ3RyYW5zZm9ybSc6ICd0cmFuc2xhdGUoMCwgJyArIGJhZ0JvdHRvbUVkZ2UgKyAncHgpJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQm9vdHMgbW92aW5nXG4gICAgICAkKCcuYm9vdHMnKS5jc3Moe1xuICAgICAgICAndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZSgnICsgLSh3U2Nyb2xsIC0gaW1nVG9wKS8zICsgJ3B4LCAwKSdcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQZW5jaWwgbW92aW5nXG4gICAgICAkKCcucGVuY2lsJykuY3NzKHtcbiAgICAgICAgJ3RyYW5zZm9ybSc6ICd0cmFuc2xhdGUoJyArICh3U2Nyb2xsIC0gaW1nVG9wKS8xMSArICdweCwgMCknXG4gICAgICB9KTtcblxuICAgICAgLy8gUGhvbmUgbW92aW5nXG4gICAgICAkKCcucGhvbmUnKS5jc3Moe1xuICAgICAgICAndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZSgwLCAnICsgLSh3U2Nyb2xsIC0gaW1nVG9wKS8xMiArICdweCknXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICogQWJvdXQgc2VjdGlvbiBmbG9hdGluZyBjb2x1bW5zXG4gICAgKi9cbiAgICBpZiAod1Njcm9sbCA+IGFib3V0QmxvY2tUb3AgLSB3SGVpZ2h0KSB7XG4gICAgICB2YXIgY29sMSA9ICQoJy5hYm91dF9fY29sdW1uLTEnKSxcbiAgICAgICAgICBjb2wyID0gJCgnLmFib3V0X19jb2x1bW4tMicpLFxuICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKDAsIHdTY3JvbGwgLSBhYm91dEJsb2NrVG9wICsgd0hlaWdodCAtIDUwMCk7XG5cblxuICAgICAgY29sMS5jc3Moe1xuICAgICAgICAndHJhbnNmb3JtJzogJ3RyYW5zbGF0ZSgnICsgb2Zmc2V0ICsgJ3B4LCAnICsgTWF0aC5hYnMob2Zmc2V0KjAuNCkgKyAncHgpJ1xuICAgICAgfSk7XG5cbiAgICAgIGNvbDIuY3NzKHtcbiAgICAgICAgJ3RyYW5zZm9ybSc6ICd0cmFuc2xhdGUoJyArIE1hdGguYWJzKG9mZnNldCkgKyAncHgsICcrIE1hdGguYWJzKG9mZnNldCowLjQpICsgJ3B4KSdcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBwdWJsaWNNZXRob2QoKSB7XG4gICAgbWFpbk1vZHVsZSA9IHtcbiAgICAgIFxuICAgIH1cbiAgfTtcblxuICB3aW5kb3cubWFpbk1vZHVsZSA9IG1haW5Nb2R1bGU7XG59KSgpO1xuIiwiOyhmdW5jdGlvbigpIHtcclxuICB2YXIgc2hvd2Nhc2VNb2R1bGUgPSB7fSxcclxuICAgICAgY2xvc2VCdG4gPSAkKCcjY2xvc2UnKSxcclxuICAgICAgd29yayA9ICQoJy53b3Jrc19fbGluaycpLFxyXG4gICAgICBzaG93Y2FzZSA9ICQoJyNzaG93Y2FzZScpLFxyXG4gICAgICBpbm5lclNob3djYXNlID0gJCgnI2lubmVyLXNob3djYXNlJyksXHJcbiAgICAgIGR1cmF0aW9uID0gMzAwLFxyXG4gICAgICBzaG9wID0ge1xyXG4gICAgICAgIGltZ1NyYzogJy4vaW1nL3Nob3AuanBnJyxcclxuICAgICAgICB0aXRsZTogJ1Nob3AnLFxyXG4gICAgICAgIHRleHQ6ICdMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzaWNpbmcgZWxpdC4gVGVuZXR1ciB2b2x1cHRhdGVzIG9iY2FlY2F0aSBkaXN0aW5jdGlvIGRpZ25pc3NpbW9zLCBkaWN0YSBkb2xvcnVtIG1vbGVzdGlhZSBpbGxvIG51bXF1YW0sIG5hbSwgZXNzZSBtaW51cy4gRWl1cyBtYWduaSBkb2xvcmVtIGZ1Z2lhdCBjb21tb2RpIHRvdGFtLCBzaW50IGlsbG8gaW5jaWR1bnQ/JyxcclxuICAgICAgICBsaW5rOiAnaHR0cDovL3Nob3AuYXBud2ViLnJ1LycsXHJcbiAgICAgICAgZmlnY2FwdHVyZTogJ1Nob3AnXHJcbiAgICAgIH0sXHJcbiAgICAgIGdlbmVyYXRvciA9IHtcclxuICAgICAgICBpbWdTcmM6ICcuL2ltZy9nZW5lcmF0b3IuanBnJyxcclxuICAgICAgICB0aXRsZTogJ0dlbmVyYXRvcicsXHJcbiAgICAgICAgdGV4dDogJ9Ct0YLQviDRgtC10LrRgdGCINGA0YvQsdCwISEg0K3RgtC+INGC0LXQutGB0YIg0YDRi9Cx0LAhISDQrdGC0L4g0YLQtdC60YHRgiDRgNGL0LHQsCEhINCt0YLQviDRgtC10LrRgdGCINGA0YvQsdCwISEg0K3RgtC+INGC0LXQutGB0YIg0YDRi9Cx0LAhISDQrdGC0L4g0YLQtdC60YHRgiDRgNGL0LHQsCEhICcsXHJcbiAgICAgICAgbGluazogJ2h0dHA6Ly93YXRlcm1hcmsudW5vc3RlY2gucnUvJyxcclxuICAgICAgICBmaWdjYXB0dXJlOiAnR2VuZXJhdG9yJ1xyXG4gICAgICB9LFxyXG4gICAgICBpcGFkQXBwcyA9IHtcclxuICAgICAgICBpbWdTcmM6ICcuL2ltZy9nZW5lcmF0b3IuanBnJyxcclxuICAgICAgICB0aXRsZTogJ0lwYWQgQXBwcycsXHJcbiAgICAgICAgdGV4dDogJ9Ct0YLQviDRgtC10LrRgdGCINGA0YvQsdCwISEg0K3RgtC+INGC0LXQutGB0YIg0YDRi9Cx0LAhISDQrdGC0L4g0YLQtdC60YHRgiDRgNGL0LHQsCEhINCt0YLQviDRgtC10LrRgdGCINGA0YvQsdCwISEg0K3RgtC+INGC0LXQutGB0YIg0YDRi9Cx0LAhISDQrdGC0L4g0YLQtdC60YHRgiDRgNGL0LHQsCEhICcsXHJcbiAgICAgICAgbGluazogJ2h0dHA6Ly9hcHBzLmFwbndlYi5ydS8nLFxyXG4gICAgICAgIGZpZ2NhcHR1cmU6ICdJcGFkIEFwcHMnXHJcbiAgICAgIH0sXHJcbiAgICAgIG9zdHJvdiA9IHtcclxuICAgICAgICBpbWdTcmM6ICcuL2ltZy9nZW5lcmF0b3IuanBnJyxcclxuICAgICAgICB0aXRsZTogJ09zdHJvdicsXHJcbiAgICAgICAgdGV4dDogJ9Ct0YLQviDRgtC10LrRgdGCINGA0YvQsdCwISEg0K3RgtC+INGC0LXQutGB0YIg0YDRi9Cx0LAhISDQrdGC0L4g0YLQtdC60YHRgiDRgNGL0LHQsCEhINCt0YLQviDRgtC10LrRgdGCINGA0YvQsdCwISEg0K3RgtC+INGC0LXQutGB0YIg0YDRi9Cx0LAhISDQrdGC0L4g0YLQtdC60YHRgiDRgNGL0LHQsCEhICcsXHJcbiAgICAgICAgbGluazogJ2h0dHA6Ly93YXRlcm1hcmsudW5vc3RlY2gucnUvJyxcclxuICAgICAgICBmaWdjYXB0dXJlOiAnT3N0cm92J1xyXG4gICAgICB9O1xyXG5cclxuICBwdWJsaWNNZXRob2QoKTtcclxuICBpbml0KCk7XHJcbiAgYXR0YWNoRXZlbnRzKCk7XHJcblxyXG4gIGZ1bmN0aW9uIGluaXQoKSB7XHJcbiAgICAvLyBTb21lIGNvZGUuLmZ1bmN0aW9ucyB0aGF0IGFyZSBuZWVkZWQgZm9yIG1vZHVsZSBpbml0aWFsaXphdGlvbiBcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XHJcbiAgICBjbG9zZUJ0bi5vbignY2xpY2snLCBjbG9zZVNob3djYXNlKTtcclxuICAgIHdvcmsub24oJ2NsaWNrJywgc2hvd1Nob3djYXNlKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBjbG9zZVNob3djYXNlKGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICBpbm5lclNob3djYXNlLnNsaWRlVXAoZHVyYXRpb24pO1xyXG4gICAgc2hvd2Nhc2UuZmFkZU91dChkdXJhdGlvbik7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gc2hvd1Nob3djYXNlKGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICB2YXIgY2xpY2sgPSAkKHRoaXMpLFxyXG4gICAgICAgIGltZyA9ICQoJyNpbWcnKSxcclxuICAgICAgICB0aXRsZSA9ICQoJyN0aXRsZScpLFxyXG4gICAgICAgIHRleHQgPSAkKCcjdGV4dCcpLFxyXG4gICAgICAgIGxpbmsgPSAkKCcubGluaycpLFxyXG4gICAgICAgIGZpZ2NhcHR1cmUgPSAkKCcjZmlnY2FwdHVyZScpO1xyXG4gICAgXHJcbiAgICBpZihjbGljay5hdHRyKCdocmVmJykgPT09ICcjc2hvcCcpIHtcclxuICAgICAgYWRkVmFsdWVzKHNob3ApO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZihjbGljay5hdHRyKCdocmVmJykgPT09ICcjZ2VuZXJhdG9yJykge1xyXG4gICAgICBhZGRWYWx1ZXMoZ2VuZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYoY2xpY2suYXR0cignaHJlZicpID09PSAnI29zdHJvdicpIHtcclxuICAgICAgYWRkVmFsdWVzKG9zdHJvdik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKGNsaWNrLmF0dHIoJ2hyZWYnKSA9PT0gJyNpcGFkQXBwcycpIHtcclxuICAgICAgYWRkVmFsdWVzKGlwYWRBcHBzKTtcclxuICAgIH1cclxuXHJcbiAgICBpbm5lclNob3djYXNlLmZhZGVJbihkdXJhdGlvbik7XHJcbiAgICBzaG93Y2FzZS5zbGlkZURvd24oZHVyYXRpb24pO1xyXG5cclxuICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtzY3JvbGxUb3A6IHNob3djYXNlLm9mZnNldCgpLnRvcH0sIGR1cmF0aW9uKVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZFZhbHVlcyhvYmopIHtcclxuICAgICAgaW1nLmF0dHIoJ3NyYycsIG9iai5pbWdTcmMpO1xyXG4gICAgICB0aXRsZS50ZXh0KG9iai50aXRsZSk7XHJcbiAgICAgIHRleHQudGV4dChvYmoudGV4dCk7XHJcbiAgICAgIGxpbmsuZWFjaChmdW5jdGlvbigpIHtcclxuICAgICAgICBsaW5rLmF0dHIoJ2hyZWYnLCBvYmoubGluaylcclxuICAgICAgfSk7XHJcbiAgICAgIGZpZ2NhcHR1cmUudGV4dChvYmouZmlnY2FwdHVyZSlcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gcHVibGljTWV0aG9kKCkge1xyXG4gICAgc2hvd2Nhc2VNb2R1bGUgPSB7XHJcbiAgICAgIC8vIG5hbWUgOiBwdWJsaWMgZnVuY3Rpb25cclxuICAgIH1cclxuICB9O1xyXG5cclxuICB3aW5kb3cuc2hvd2Nhc2VNb2R1bGUgPSBzaG93Y2FzZU1vZHVsZTtcclxufSkoKTtcclxuIiwidmFyIHR5cGUgPSByZXF1aXJlKCcuLi9ib3dlci90eXBlZC5qcy9qcy90eXBlZC5qcycpO1xyXG52YXIgbWFpbiA9IHJlcXVpcmUoJy4vX21vZHVsZXMvbWFpbi5qcycpO1xyXG52YXIgc2hvd2Nhc2UgPSByZXF1aXJlKCcuL19tb2R1bGVzL3Nob3djYXNlLmpzJyk7XHJcbnZhciBmb3JtID0gcmVxdWlyZSgnLi9fbW9kdWxlcy9mb3JtLmpzJyk7XHJcbiJdfQ==
