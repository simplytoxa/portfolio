(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// The MIT License (MIT)

// Typed.js | Copyright (c) 2014 Matt Boldt | www.mattboldt.com

// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:

// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




! function($) {

    "use strict";

    var Typed = function(el, options) {

        // chosen element to manipulate text
        this.el = $(el);

        // options
        this.options = $.extend({}, $.fn.typed.defaults, options);

        // attribute to type into
        this.isInput = this.el.is('input');
        this.attr = this.options.attr;

        // show cursor
        this.showCursor = this.isInput ? false : this.options.showCursor;

        // text content of element
        this.elContent = this.attr ? this.el.attr(this.attr) : this.el.text()

        // html or plain text
        this.contentType = this.options.contentType;

        // typing speed
        this.typeSpeed = this.options.typeSpeed;

        // add a delay before typing starts
        this.startDelay = this.options.startDelay;

        // backspacing speed
        this.backSpeed = this.options.backSpeed;

        // amount of time to wait before backspacing
        this.backDelay = this.options.backDelay;

        // input strings of text
        this.strings = this.options.strings;

        // character number position of current string
        this.strPos = 0;

        // current array position
        this.arrayPos = 0;

        // number to stop backspacing on.
        // default 0, can change depending on how many chars
        // you want to remove at the time
        this.stopNum = 0;

        // Looping logic
        this.loop = this.options.loop;
        this.loopCount = this.options.loopCount;
        this.curLoop = 0;

        // for stopping
        this.stop = false;

        // custom cursor
        this.cursorChar = this.options.cursorChar;

        // shuffle the strings
        this.shuffle = this.options.shuffle;
        // the order of strings
        this.sequence = [];

        // All systems go!
        this.build();
    };

    Typed.prototype = {

        constructor: Typed

        ,
        init: function() {
            // begin the loop w/ first current string (global self.string)
            // current string will be passed as an argument each time after this
            var self = this;
            self.timeout = setTimeout(function() {
                for (var i=0;i<self.strings.length;++i) self.sequence[i]=i;

                // shuffle the array if true
                if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);

                // Start typing
                self.typewrite(self.strings[self.sequence[self.arrayPos]], self.strPos);
            }, self.startDelay);
        }

        ,
        build: function() {
            // Insert cursor
            if (this.showCursor === true) {
                this.cursor = $("<span class=\"typed-cursor\">" + this.cursorChar + "</span>");
                this.el.after(this.cursor);
            }
            this.init();
        }

        // pass current string state to each function, types 1 char per call
        ,
        typewrite: function(curString, curStrPos) {
            // exit when stopped
            if (this.stop === true) {
                return;
            }

            // varying values for setTimeout during typing
            // can't be global since number changes each time loop is executed
            var humanize = Math.round(Math.random() * (100 - 30)) + this.typeSpeed;
            var self = this;

            // ------------- optional ------------- //
            // backpaces a certain string faster
            // ------------------------------------ //
            // if (self.arrayPos == 1){
            //  self.backDelay = 50;
            // }
            // else{ self.backDelay = 500; }

            // contain typing function in a timeout humanize'd delay
            self.timeout = setTimeout(function() {
                // check for an escape character before a pause value
                // format: \^\d+ .. eg: ^1000 .. should be able to print the ^ too using ^^
                // single ^ are removed from string
                var charPause = 0;
                var substr = curString.substr(curStrPos);
                if (substr.charAt(0) === '^') {
                    var skip = 1; // skip atleast 1
                    if (/^\^\d+/.test(substr)) {
                        substr = /\d+/.exec(substr)[0];
                        skip += substr.length;
                        charPause = parseInt(substr);
                    }

                    // strip out the escape character and pause value so they're not printed
                    curString = curString.substring(0, curStrPos) + curString.substring(curStrPos + skip);
                }

                if (self.contentType === 'html') {
                    // skip over html tags while typing
                    var curChar = curString.substr(curStrPos).charAt(0)
                    if (curChar === '<' || curChar === '&') {
                        var tag = '';
                        var endTag = '';
                        if (curChar === '<') {
                            endTag = '>'
                        } else {
                            endTag = ';'
                        }
                        while (curString.substr(curStrPos).charAt(0) !== endTag) {
                            tag += curString.substr(curStrPos).charAt(0);
                            curStrPos++;
                        }
                        curStrPos++;
                        tag += endTag;
                    }
                }

                // timeout for any pause after a character
                self.timeout = setTimeout(function() {
                    if (curStrPos === curString.length) {
                        // fires callback function
                        self.options.onStringTyped(self.arrayPos);

                        // is this the final string
                        if (self.arrayPos === self.strings.length - 1) {
                            // animation that occurs on the last typed string
                            self.options.callback();

                            self.curLoop++;

                            // quit if we wont loop back
                            if (self.loop === false || self.curLoop === self.loopCount)
                                return;
                        }

                        self.timeout = setTimeout(function() {
                            self.backspace(curString, curStrPos);
                        }, self.backDelay);
                    } else {

                        /* call before functions if applicable */
                        if (curStrPos === 0)
                            self.options.preStringTyped(self.arrayPos);

                        // start typing each new char into existing string
                        // curString: arg, self.el.html: original text inside element
                        var nextString = curString.substr(0, curStrPos + 1);
                        if (self.attr) {
                            self.el.attr(self.attr, nextString);
                        } else {
                            if (self.isInput) {
                                self.el.val(nextString);
                            } else if (self.contentType === 'html') {
                                self.el.html(nextString);
                            } else {
                                self.el.text(nextString);
                            }
                        }

                        // add characters one by one
                        curStrPos++;
                        // loop the function
                        self.typewrite(curString, curStrPos);
                    }
                    // end of character pause
                }, charPause);

                // humanized value for typing
            }, humanize);

        }

        ,
        backspace: function(curString, curStrPos) {
            // exit when stopped
            if (this.stop === true) {
                return;
            }

            // varying values for setTimeout during typing
            // can't be global since number changes each time loop is executed
            var humanize = Math.round(Math.random() * (100 - 30)) + this.backSpeed;
            var self = this;

            self.timeout = setTimeout(function() {

                // ----- this part is optional ----- //
                // check string array position
                // on the first string, only delete one word
                // the stopNum actually represents the amount of chars to
                // keep in the current string. In my case it's 14.
                // if (self.arrayPos == 1){
                //  self.stopNum = 14;
                // }
                //every other time, delete the whole typed string
                // else{
                //  self.stopNum = 0;
                // }

                if (self.contentType === 'html') {
                    // skip over html tags while backspacing
                    if (curString.substr(curStrPos).charAt(0) === '>') {
                        var tag = '';
                        while (curString.substr(curStrPos).charAt(0) !== '<') {
                            tag -= curString.substr(curStrPos).charAt(0);
                            curStrPos--;
                        }
                        curStrPos--;
                        tag += '<';
                    }
                }

                // ----- continue important stuff ----- //
                // replace text with base text + typed characters
                var nextString = curString.substr(0, curStrPos);
                if (self.attr) {
                    self.el.attr(self.attr, nextString);
                } else {
                    if (self.isInput) {
                        self.el.val(nextString);
                    } else if (self.contentType === 'html') {
                        self.el.html(nextString);
                    } else {
                        self.el.text(nextString);
                    }
                }

                // if the number (id of character in current string) is
                // less than the stop number, keep going
                if (curStrPos > self.stopNum) {
                    // subtract characters one by one
                    curStrPos--;
                    // loop the function
                    self.backspace(curString, curStrPos);
                }
                // if the stop number has been reached, increase
                // array position to next string
                else if (curStrPos <= self.stopNum) {
                    self.arrayPos++;

                    if (self.arrayPos === self.strings.length) {
                        self.arrayPos = 0;

                        // Shuffle sequence again
                        if(self.shuffle) self.sequence = self.shuffleArray(self.sequence);

                        self.init();
                    } else
                        self.typewrite(self.strings[self.sequence[self.arrayPos]], curStrPos);
                }

                // humanized value for typing
            }, humanize);

        }
        /**
         * Shuffles the numbers in the given array.
         * @param {Array} array
         * @returns {Array}
         */
        ,shuffleArray: function(array) {
            var tmp, current, top = array.length;
            if(top) while(--top) {
                current = Math.floor(Math.random() * (top + 1));
                tmp = array[current];
                array[current] = array[top];
                array[top] = tmp;
            }
            return array;
        }

        // Start & Stop currently not working

        // , stop: function() {
        //     var self = this;

        //     self.stop = true;
        //     clearInterval(self.timeout);
        // }

        // , start: function() {
        //     var self = this;
        //     if(self.stop === false)
        //        return;

        //     this.stop = false;
        //     this.init();
        // }

        // Reset and rebuild the element
        ,
        reset: function() {
            var self = this;
            clearInterval(self.timeout);
            var id = this.el.attr('id');
            this.el.after('<span id="' + id + '"/>')
            this.el.remove();
            if (typeof this.cursor !== 'undefined') {
                this.cursor.remove();
            }
            // Send the callback
            self.options.resetCallback();
        }

    };

    $.fn.typed = function(option) {
        return this.each(function() {
            var $this = $(this),
                data = $this.data('typed'),
                options = typeof option == 'object' && option;
            if (!data) $this.data('typed', (data = new Typed(this, options)));
            if (typeof option == 'string') data[option]();
        });
    };

    $.fn.typed.defaults = {
        strings: ["These are the default values...", "You know what you should do?", "Use your own!", "Have a great day!"],
        // typing speed
        typeSpeed: 0,
        // time before typing starts
        startDelay: 0,
        // backspacing speed
        backSpeed: 0,
        // shuffle the strings
        shuffle: false,
        // time before backspacing
        backDelay: 500,
        // loop
        loop: false,
        // false = infinite
        loopCount: false,
        // show cursor
        showCursor: true,
        // character for cursor
        cursorChar: "|",
        // attribute to type (null == text)
        attr: null,
        // either html or text
        contentType: 'html',
        // call when done callback function
        callback: function() {},
        // starting callback function before each string
        preStringTyped: function() {},
        //callback for every typed string
        onStringTyped: function() {},
        // callback for reset
        resetCallback: function() {}
    };


}(window.jQuery);

},{}],2:[function(require,module,exports){
;(function() {
  var mainModule = {},
      toTopBtn = $('#back-to-top');

  publicMethod();
  init();
  attachEvents();

  function init() {
    $('.intro__text1').typed({
      strings: ["I'm Anton Povzun."],
      typeSpeed: 50,
      showCursor: false,
      callback: introText2
    });
  
  };

  function attachEvents() {
    $(window).on('scroll', showToTopBtn);
    toTopBtn.on('click', scrollToTheTop);
    $('nav.menu').on('click', 'a', anchorScroll);
  };

  function introText2() {
    $('.intro__text2').typed({
      strings: ['A robot from the future', 'A front-end developer '],
      typeSpeed: 50,
      backDelay: 700,
      showCursor: false,
      callback: introText3
     });
  };
  

  function introText3() {
    $('.intro__text3').typed({
      strings: ["I like to make cool stuff."],
      showCursor: false,
      typeSpeed: 50
     });
  };

  function showToTopBtn() {
    var scrollTop = $(window).scrollTop();

    if (scrollTop > 1000) {
      toTopBtn.fadeIn(600);
    } else {
      toTopBtn.fadeOut(600);
    }
  };

  function scrollToTheTop(e) {
    e.preventDefault();

    var head = $('#head'),
        top = head.offset().top;

    $('html, body').animate({scrollTop: top}, 1000);
  };

  function anchorScroll(e) {
    e.preventDefault();

    var id = $(this).attr('href'),
        top = $(id).offset().top;

    $('html, body').animate({scrollTop: top}, 1000);
  };

  function publicMethod() {
    mainModule = {
      
    }
  };

  window.mainModule = mainModule;
})();

},{}],3:[function(require,module,exports){
;(function() {
  var myModule = {},
      closeBtn = $('#close');

  publicMethod();
  init();
  attachEvents();

  function init() {
    // Some code..functions that are needed for module initialization 
  };

  function attachEvents() {
    closeBtn.on('click', closeShowcase);
  };

  function closeShowcase(e) {
    e.preventDefault();
    console.log('sss');

    var showcase = $('#showcase'),
        innerShowcase = $('#inner-showcase');

    innerShowcase.slideUp(1000);
    showcase.fadeOut(1000, 'linear');
  };

  function publicMethod() {
    myModule = {
      // name : public function
    }
  };

  window.myModule = myModule;
})();

},{}],4:[function(require,module,exports){
var type = require('../bower/typed.js/js/typed.js');
var main = require('./_modules/main.js');
var showcase = require('./_modules/showcase.js');
},{"../bower/typed.js/js/typed.js":1,"./_modules/main.js":2,"./_modules/showcase.js":3}]},{},[4])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkQ6XFxPcGVuc2VydmVyXFxkb21haW5zXFxwb3J0Zm9saW9cXG5vZGVfbW9kdWxlc1xcYnJvd3Nlci1wYWNrXFxfcHJlbHVkZS5qcyIsIkQ6L09wZW5zZXJ2ZXIvZG9tYWlucy9wb3J0Zm9saW8vYXBwL2Jvd2VyL3R5cGVkLmpzL2pzL3R5cGVkLmpzIiwiRDovT3BlbnNlcnZlci9kb21haW5zL3BvcnRmb2xpby9hcHAvanMvX21vZHVsZXMvbWFpbi5qcyIsIkQ6L09wZW5zZXJ2ZXIvZG9tYWlucy9wb3J0Zm9saW8vYXBwL2pzL19tb2R1bGVzL3Nob3djYXNlLmpzIiwiRDovT3BlbnNlcnZlci9kb21haW5zL3BvcnRmb2xpby9hcHAvanMvZmFrZV84NDJmNjdkZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8vIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuXG4vLyBUeXBlZC5qcyB8IENvcHlyaWdodCAoYykgMjAxNCBNYXR0IEJvbGR0IHwgd3d3Lm1hdHRib2xkdC5jb21cblxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuLy8gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuLy8gVEhFIFNPRlRXQVJFLlxuXG5cblxuXG4hIGZ1bmN0aW9uKCQpIHtcblxuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIFR5cGVkID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcblxuICAgICAgICAvLyBjaG9zZW4gZWxlbWVudCB0byBtYW5pcHVsYXRlIHRleHRcbiAgICAgICAgdGhpcy5lbCA9ICQoZWwpO1xuXG4gICAgICAgIC8vIG9wdGlvbnNcbiAgICAgICAgdGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sICQuZm4udHlwZWQuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGF0dHJpYnV0ZSB0byB0eXBlIGludG9cbiAgICAgICAgdGhpcy5pc0lucHV0ID0gdGhpcy5lbC5pcygnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5hdHRyID0gdGhpcy5vcHRpb25zLmF0dHI7XG5cbiAgICAgICAgLy8gc2hvdyBjdXJzb3JcbiAgICAgICAgdGhpcy5zaG93Q3Vyc29yID0gdGhpcy5pc0lucHV0ID8gZmFsc2UgOiB0aGlzLm9wdGlvbnMuc2hvd0N1cnNvcjtcblxuICAgICAgICAvLyB0ZXh0IGNvbnRlbnQgb2YgZWxlbWVudFxuICAgICAgICB0aGlzLmVsQ29udGVudCA9IHRoaXMuYXR0ciA/IHRoaXMuZWwuYXR0cih0aGlzLmF0dHIpIDogdGhpcy5lbC50ZXh0KClcblxuICAgICAgICAvLyBodG1sIG9yIHBsYWluIHRleHRcbiAgICAgICAgdGhpcy5jb250ZW50VHlwZSA9IHRoaXMub3B0aW9ucy5jb250ZW50VHlwZTtcblxuICAgICAgICAvLyB0eXBpbmcgc3BlZWRcbiAgICAgICAgdGhpcy50eXBlU3BlZWQgPSB0aGlzLm9wdGlvbnMudHlwZVNwZWVkO1xuXG4gICAgICAgIC8vIGFkZCBhIGRlbGF5IGJlZm9yZSB0eXBpbmcgc3RhcnRzXG4gICAgICAgIHRoaXMuc3RhcnREZWxheSA9IHRoaXMub3B0aW9ucy5zdGFydERlbGF5O1xuXG4gICAgICAgIC8vIGJhY2tzcGFjaW5nIHNwZWVkXG4gICAgICAgIHRoaXMuYmFja1NwZWVkID0gdGhpcy5vcHRpb25zLmJhY2tTcGVlZDtcblxuICAgICAgICAvLyBhbW91bnQgb2YgdGltZSB0byB3YWl0IGJlZm9yZSBiYWNrc3BhY2luZ1xuICAgICAgICB0aGlzLmJhY2tEZWxheSA9IHRoaXMub3B0aW9ucy5iYWNrRGVsYXk7XG5cbiAgICAgICAgLy8gaW5wdXQgc3RyaW5ncyBvZiB0ZXh0XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHRoaXMub3B0aW9ucy5zdHJpbmdzO1xuXG4gICAgICAgIC8vIGNoYXJhY3RlciBudW1iZXIgcG9zaXRpb24gb2YgY3VycmVudCBzdHJpbmdcbiAgICAgICAgdGhpcy5zdHJQb3MgPSAwO1xuXG4gICAgICAgIC8vIGN1cnJlbnQgYXJyYXkgcG9zaXRpb25cbiAgICAgICAgdGhpcy5hcnJheVBvcyA9IDA7XG5cbiAgICAgICAgLy8gbnVtYmVyIHRvIHN0b3AgYmFja3NwYWNpbmcgb24uXG4gICAgICAgIC8vIGRlZmF1bHQgMCwgY2FuIGNoYW5nZSBkZXBlbmRpbmcgb24gaG93IG1hbnkgY2hhcnNcbiAgICAgICAgLy8geW91IHdhbnQgdG8gcmVtb3ZlIGF0IHRoZSB0aW1lXG4gICAgICAgIHRoaXMuc3RvcE51bSA9IDA7XG5cbiAgICAgICAgLy8gTG9vcGluZyBsb2dpY1xuICAgICAgICB0aGlzLmxvb3AgPSB0aGlzLm9wdGlvbnMubG9vcDtcbiAgICAgICAgdGhpcy5sb29wQ291bnQgPSB0aGlzLm9wdGlvbnMubG9vcENvdW50O1xuICAgICAgICB0aGlzLmN1ckxvb3AgPSAwO1xuXG4gICAgICAgIC8vIGZvciBzdG9wcGluZ1xuICAgICAgICB0aGlzLnN0b3AgPSBmYWxzZTtcblxuICAgICAgICAvLyBjdXN0b20gY3Vyc29yXG4gICAgICAgIHRoaXMuY3Vyc29yQ2hhciA9IHRoaXMub3B0aW9ucy5jdXJzb3JDaGFyO1xuXG4gICAgICAgIC8vIHNodWZmbGUgdGhlIHN0cmluZ3NcbiAgICAgICAgdGhpcy5zaHVmZmxlID0gdGhpcy5vcHRpb25zLnNodWZmbGU7XG4gICAgICAgIC8vIHRoZSBvcmRlciBvZiBzdHJpbmdzXG4gICAgICAgIHRoaXMuc2VxdWVuY2UgPSBbXTtcblxuICAgICAgICAvLyBBbGwgc3lzdGVtcyBnbyFcbiAgICAgICAgdGhpcy5idWlsZCgpO1xuICAgIH07XG5cbiAgICBUeXBlZC5wcm90b3R5cGUgPSB7XG5cbiAgICAgICAgY29uc3RydWN0b3I6IFR5cGVkXG5cbiAgICAgICAgLFxuICAgICAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIGJlZ2luIHRoZSBsb29wIHcvIGZpcnN0IGN1cnJlbnQgc3RyaW5nIChnbG9iYWwgc2VsZi5zdHJpbmcpXG4gICAgICAgICAgICAvLyBjdXJyZW50IHN0cmluZyB3aWxsIGJlIHBhc3NlZCBhcyBhbiBhcmd1bWVudCBlYWNoIHRpbWUgYWZ0ZXIgdGhpc1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpPTA7aTxzZWxmLnN0cmluZ3MubGVuZ3RoOysraSkgc2VsZi5zZXF1ZW5jZVtpXT1pO1xuXG4gICAgICAgICAgICAgICAgLy8gc2h1ZmZsZSB0aGUgYXJyYXkgaWYgdHJ1ZVxuICAgICAgICAgICAgICAgIGlmKHNlbGYuc2h1ZmZsZSkgc2VsZi5zZXF1ZW5jZSA9IHNlbGYuc2h1ZmZsZUFycmF5KHNlbGYuc2VxdWVuY2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgdHlwaW5nXG4gICAgICAgICAgICAgICAgc2VsZi50eXBld3JpdGUoc2VsZi5zdHJpbmdzW3NlbGYuc2VxdWVuY2Vbc2VsZi5hcnJheVBvc11dLCBzZWxmLnN0clBvcyk7XG4gICAgICAgICAgICB9LCBzZWxmLnN0YXJ0RGVsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLFxuICAgICAgICBidWlsZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgY3Vyc29yXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93Q3Vyc29yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAkKFwiPHNwYW4gY2xhc3M9XFxcInR5cGVkLWN1cnNvclxcXCI+XCIgKyB0aGlzLmN1cnNvckNoYXIgKyBcIjwvc3Bhbj5cIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hZnRlcih0aGlzLmN1cnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhc3MgY3VycmVudCBzdHJpbmcgc3RhdGUgdG8gZWFjaCBmdW5jdGlvbiwgdHlwZXMgMSBjaGFyIHBlciBjYWxsXG4gICAgICAgICxcbiAgICAgICAgdHlwZXdyaXRlOiBmdW5jdGlvbihjdXJTdHJpbmcsIGN1clN0clBvcykge1xuICAgICAgICAgICAgLy8gZXhpdCB3aGVuIHN0b3BwZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhcnlpbmcgdmFsdWVzIGZvciBzZXRUaW1lb3V0IGR1cmluZyB0eXBpbmdcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIGdsb2JhbCBzaW5jZSBudW1iZXIgY2hhbmdlcyBlYWNoIHRpbWUgbG9vcCBpcyBleGVjdXRlZFxuICAgICAgICAgICAgdmFyIGh1bWFuaXplID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDEwMCAtIDMwKSkgKyB0aGlzLnR5cGVTcGVlZDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBvcHRpb25hbCAtLS0tLS0tLS0tLS0tIC8vXG4gICAgICAgICAgICAvLyBiYWNrcGFjZXMgYSBjZXJ0YWluIHN0cmluZyBmYXN0ZXJcbiAgICAgICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuICAgICAgICAgICAgLy8gaWYgKHNlbGYuYXJyYXlQb3MgPT0gMSl7XG4gICAgICAgICAgICAvLyAgc2VsZi5iYWNrRGVsYXkgPSA1MDtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGVsc2V7IHNlbGYuYmFja0RlbGF5ID0gNTAwOyB9XG5cbiAgICAgICAgICAgIC8vIGNvbnRhaW4gdHlwaW5nIGZ1bmN0aW9uIGluIGEgdGltZW91dCBodW1hbml6ZSdkIGRlbGF5XG4gICAgICAgICAgICBzZWxmLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBhbiBlc2NhcGUgY2hhcmFjdGVyIGJlZm9yZSBhIHBhdXNlIHZhbHVlXG4gICAgICAgICAgICAgICAgLy8gZm9ybWF0OiBcXF5cXGQrIC4uIGVnOiBeMTAwMCAuLiBzaG91bGQgYmUgYWJsZSB0byBwcmludCB0aGUgXiB0b28gdXNpbmcgXl5cbiAgICAgICAgICAgICAgICAvLyBzaW5nbGUgXiBhcmUgcmVtb3ZlZCBmcm9tIHN0cmluZ1xuICAgICAgICAgICAgICAgIHZhciBjaGFyUGF1c2UgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBzdWJzdHIgPSBjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnN0ci5jaGFyQXQoMCkgPT09ICdeJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcCA9IDE7IC8vIHNraXAgYXRsZWFzdCAxXG4gICAgICAgICAgICAgICAgICAgIGlmICgvXlxcXlxcZCsvLnRlc3Qoc3Vic3RyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3Vic3RyID0gL1xcZCsvLmV4ZWMoc3Vic3RyKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNraXAgKz0gc3Vic3RyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJQYXVzZSA9IHBhcnNlSW50KHN1YnN0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpcCBvdXQgdGhlIGVzY2FwZSBjaGFyYWN0ZXIgYW5kIHBhdXNlIHZhbHVlIHNvIHRoZXkncmUgbm90IHByaW50ZWRcbiAgICAgICAgICAgICAgICAgICAgY3VyU3RyaW5nID0gY3VyU3RyaW5nLnN1YnN0cmluZygwLCBjdXJTdHJQb3MpICsgY3VyU3RyaW5nLnN1YnN0cmluZyhjdXJTdHJQb3MgKyBza2lwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb250ZW50VHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgb3ZlciBodG1sIHRhZ3Mgd2hpbGUgdHlwaW5nXG4gICAgICAgICAgICAgICAgICAgIHZhciBjdXJDaGFyID0gY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQ2hhciA9PT0gJzwnIHx8IGN1ckNoYXIgPT09ICcmJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRhZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVuZFRhZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ckNoYXIgPT09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZFRhZyA9ICc+J1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmRUYWcgPSAnOydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJTdHJpbmcuc3Vic3RyKGN1clN0clBvcykuY2hhckF0KDApICE9PSBlbmRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWcgKz0gY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJTdHJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clN0clBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFnICs9IGVuZFRhZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHRpbWVvdXQgZm9yIGFueSBwYXVzZSBhZnRlciBhIGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJTdHJQb3MgPT09IGN1clN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpcmVzIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMub25TdHJpbmdUeXBlZChzZWxmLmFycmF5UG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdGhpcyB0aGUgZmluYWwgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcnJheVBvcyA9PT0gc2VsZi5zdHJpbmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmltYXRpb24gdGhhdCBvY2N1cnMgb24gdGhlIGxhc3QgdHlwZWQgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLmNhbGxiYWNrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmN1ckxvb3ArKztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHF1aXQgaWYgd2Ugd29udCBsb29wIGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5sb29wID09PSBmYWxzZSB8fCBzZWxmLmN1ckxvb3AgPT09IHNlbGYubG9vcENvdW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5iYWNrc3BhY2UoY3VyU3RyaW5nLCBjdXJTdHJQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgc2VsZi5iYWNrRGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBjYWxsIGJlZm9yZSBmdW5jdGlvbnMgaWYgYXBwbGljYWJsZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1clN0clBvcyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMucHJlU3RyaW5nVHlwZWQoc2VsZi5hcnJheVBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHR5cGluZyBlYWNoIG5ldyBjaGFyIGludG8gZXhpc3Rpbmcgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJTdHJpbmc6IGFyZywgc2VsZi5lbC5odG1sOiBvcmlnaW5hbCB0ZXh0IGluc2lkZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dFN0cmluZyA9IGN1clN0cmluZy5zdWJzdHIoMCwgY3VyU3RyUG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC5hdHRyKHNlbGYuYXR0ciwgbmV4dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLmlzSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC52YWwobmV4dFN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbC5odG1sKG5leHRTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWwudGV4dChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBjaGFyYWN0ZXJzIG9uZSBieSBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clN0clBvcysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYudHlwZXdyaXRlKGN1clN0cmluZywgY3VyU3RyUG9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBlbmQgb2YgY2hhcmFjdGVyIHBhdXNlXG4gICAgICAgICAgICAgICAgfSwgY2hhclBhdXNlKTtcblxuICAgICAgICAgICAgICAgIC8vIGh1bWFuaXplZCB2YWx1ZSBmb3IgdHlwaW5nXG4gICAgICAgICAgICB9LCBodW1hbml6ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgICxcbiAgICAgICAgYmFja3NwYWNlOiBmdW5jdGlvbihjdXJTdHJpbmcsIGN1clN0clBvcykge1xuICAgICAgICAgICAgLy8gZXhpdCB3aGVuIHN0b3BwZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhcnlpbmcgdmFsdWVzIGZvciBzZXRUaW1lb3V0IGR1cmluZyB0eXBpbmdcbiAgICAgICAgICAgIC8vIGNhbid0IGJlIGdsb2JhbCBzaW5jZSBudW1iZXIgY2hhbmdlcyBlYWNoIHRpbWUgbG9vcCBpcyBleGVjdXRlZFxuICAgICAgICAgICAgdmFyIGh1bWFuaXplID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKDEwMCAtIDMwKSkgKyB0aGlzLmJhY2tTcGVlZDtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgc2VsZi50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIC8vIC0tLS0tIHRoaXMgcGFydCBpcyBvcHRpb25hbCAtLS0tLSAvL1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHN0cmluZyBhcnJheSBwb3NpdGlvblxuICAgICAgICAgICAgICAgIC8vIG9uIHRoZSBmaXJzdCBzdHJpbmcsIG9ubHkgZGVsZXRlIG9uZSB3b3JkXG4gICAgICAgICAgICAgICAgLy8gdGhlIHN0b3BOdW0gYWN0dWFsbHkgcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGNoYXJzIHRvXG4gICAgICAgICAgICAgICAgLy8ga2VlcCBpbiB0aGUgY3VycmVudCBzdHJpbmcuIEluIG15IGNhc2UgaXQncyAxNC5cbiAgICAgICAgICAgICAgICAvLyBpZiAoc2VsZi5hcnJheVBvcyA9PSAxKXtcbiAgICAgICAgICAgICAgICAvLyAgc2VsZi5zdG9wTnVtID0gMTQ7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vZXZlcnkgb3RoZXIgdGltZSwgZGVsZXRlIHRoZSB3aG9sZSB0eXBlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAvLyBlbHNle1xuICAgICAgICAgICAgICAgIC8vICBzZWxmLnN0b3BOdW0gPSAwO1xuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxmLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBvdmVyIGh0bWwgdGFncyB3aGlsZSBiYWNrc3BhY2luZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKSA9PT0gJz4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFnID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VyU3RyaW5nLnN1YnN0cihjdXJTdHJQb3MpLmNoYXJBdCgwKSAhPT0gJzwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnIC09IGN1clN0cmluZy5zdWJzdHIoY3VyU3RyUG9zKS5jaGFyQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyU3RyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJTdHJQb3MtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZyArPSAnPCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAtLS0tLSBjb250aW51ZSBpbXBvcnRhbnQgc3R1ZmYgLS0tLS0gLy9cbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRleHQgd2l0aCBiYXNlIHRleHQgKyB0eXBlZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdHJpbmcgPSBjdXJTdHJpbmcuc3Vic3RyKDAsIGN1clN0clBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVsLmF0dHIoc2VsZi5hdHRyLCBuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0lucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVsLnZhbChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWwuaHRtbChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZWwudGV4dChuZXh0U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBudW1iZXIgKGlkIG9mIGNoYXJhY3RlciBpbiBjdXJyZW50IHN0cmluZykgaXNcbiAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHN0b3AgbnVtYmVyLCBrZWVwIGdvaW5nXG4gICAgICAgICAgICAgICAgaWYgKGN1clN0clBvcyA+IHNlbGYuc3RvcE51bSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdWJ0cmFjdCBjaGFyYWN0ZXJzIG9uZSBieSBvbmVcbiAgICAgICAgICAgICAgICAgICAgY3VyU3RyUG9zLS07XG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYmFja3NwYWNlKGN1clN0cmluZywgY3VyU3RyUG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0b3AgbnVtYmVyIGhhcyBiZWVuIHJlYWNoZWQsIGluY3JlYXNlXG4gICAgICAgICAgICAgICAgLy8gYXJyYXkgcG9zaXRpb24gdG8gbmV4dCBzdHJpbmdcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJTdHJQb3MgPD0gc2VsZi5zdG9wTnVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYXJyYXlQb3MrKztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5hcnJheVBvcyA9PT0gc2VsZi5zdHJpbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5hcnJheVBvcyA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNodWZmbGUgc2VxdWVuY2UgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGYuc2h1ZmZsZSkgc2VsZi5zZXF1ZW5jZSA9IHNlbGYuc2h1ZmZsZUFycmF5KHNlbGYuc2VxdWVuY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnR5cGV3cml0ZShzZWxmLnN0cmluZ3Nbc2VsZi5zZXF1ZW5jZVtzZWxmLmFycmF5UG9zXV0sIGN1clN0clBvcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaHVtYW5pemVkIHZhbHVlIGZvciB0eXBpbmdcbiAgICAgICAgICAgIH0sIGh1bWFuaXplKTtcblxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaHVmZmxlcyB0aGUgbnVtYmVycyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgICxzaHVmZmxlQXJyYXk6IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgdG1wLCBjdXJyZW50LCB0b3AgPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgICBpZih0b3ApIHdoaWxlKC0tdG9wKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICh0b3AgKyAxKSk7XG4gICAgICAgICAgICAgICAgdG1wID0gYXJyYXlbY3VycmVudF07XG4gICAgICAgICAgICAgICAgYXJyYXlbY3VycmVudF0gPSBhcnJheVt0b3BdO1xuICAgICAgICAgICAgICAgIGFycmF5W3RvcF0gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGFydCAmIFN0b3AgY3VycmVudGx5IG5vdCB3b3JraW5nXG5cbiAgICAgICAgLy8gLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAvLyAgICAgc2VsZi5zdG9wID0gdHJ1ZTtcbiAgICAgICAgLy8gICAgIGNsZWFySW50ZXJ2YWwoc2VsZi50aW1lb3V0KTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vICwgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvLyAgICAgaWYoc2VsZi5zdG9wID09PSBmYWxzZSlcbiAgICAgICAgLy8gICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyAgICAgdGhpcy5zdG9wID0gZmFsc2U7XG4gICAgICAgIC8vICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIFJlc2V0IGFuZCByZWJ1aWxkIHRoZSBlbGVtZW50XG4gICAgICAgICxcbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLnRpbWVvdXQpO1xuICAgICAgICAgICAgdmFyIGlkID0gdGhpcy5lbC5hdHRyKCdpZCcpO1xuICAgICAgICAgICAgdGhpcy5lbC5hZnRlcignPHNwYW4gaWQ9XCInICsgaWQgKyAnXCIvPicpXG4gICAgICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmN1cnNvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvci5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNlbmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICBzZWxmLm9wdGlvbnMucmVzZXRDYWxsYmFjaygpO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgJC5mbi50eXBlZCA9IGZ1bmN0aW9uKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgndHlwZWQnKSxcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PSAnb2JqZWN0JyAmJiBvcHRpb247XG4gICAgICAgICAgICBpZiAoIWRhdGEpICR0aGlzLmRhdGEoJ3R5cGVkJywgKGRhdGEgPSBuZXcgVHlwZWQodGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSBkYXRhW29wdGlvbl0oKTtcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgICQuZm4udHlwZWQuZGVmYXVsdHMgPSB7XG4gICAgICAgIHN0cmluZ3M6IFtcIlRoZXNlIGFyZSB0aGUgZGVmYXVsdCB2YWx1ZXMuLi5cIiwgXCJZb3Uga25vdyB3aGF0IHlvdSBzaG91bGQgZG8/XCIsIFwiVXNlIHlvdXIgb3duIVwiLCBcIkhhdmUgYSBncmVhdCBkYXkhXCJdLFxuICAgICAgICAvLyB0eXBpbmcgc3BlZWRcbiAgICAgICAgdHlwZVNwZWVkOiAwLFxuICAgICAgICAvLyB0aW1lIGJlZm9yZSB0eXBpbmcgc3RhcnRzXG4gICAgICAgIHN0YXJ0RGVsYXk6IDAsXG4gICAgICAgIC8vIGJhY2tzcGFjaW5nIHNwZWVkXG4gICAgICAgIGJhY2tTcGVlZDogMCxcbiAgICAgICAgLy8gc2h1ZmZsZSB0aGUgc3RyaW5nc1xuICAgICAgICBzaHVmZmxlOiBmYWxzZSxcbiAgICAgICAgLy8gdGltZSBiZWZvcmUgYmFja3NwYWNpbmdcbiAgICAgICAgYmFja0RlbGF5OiA1MDAsXG4gICAgICAgIC8vIGxvb3BcbiAgICAgICAgbG9vcDogZmFsc2UsXG4gICAgICAgIC8vIGZhbHNlID0gaW5maW5pdGVcbiAgICAgICAgbG9vcENvdW50OiBmYWxzZSxcbiAgICAgICAgLy8gc2hvdyBjdXJzb3JcbiAgICAgICAgc2hvd0N1cnNvcjogdHJ1ZSxcbiAgICAgICAgLy8gY2hhcmFjdGVyIGZvciBjdXJzb3JcbiAgICAgICAgY3Vyc29yQ2hhcjogXCJ8XCIsXG4gICAgICAgIC8vIGF0dHJpYnV0ZSB0byB0eXBlIChudWxsID09IHRleHQpXG4gICAgICAgIGF0dHI6IG51bGwsXG4gICAgICAgIC8vIGVpdGhlciBodG1sIG9yIHRleHRcbiAgICAgICAgY29udGVudFR5cGU6ICdodG1sJyxcbiAgICAgICAgLy8gY2FsbCB3aGVuIGRvbmUgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIC8vIHN0YXJ0aW5nIGNhbGxiYWNrIGZ1bmN0aW9uIGJlZm9yZSBlYWNoIHN0cmluZ1xuICAgICAgICBwcmVTdHJpbmdUeXBlZDogZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgLy9jYWxsYmFjayBmb3IgZXZlcnkgdHlwZWQgc3RyaW5nXG4gICAgICAgIG9uU3RyaW5nVHlwZWQ6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIC8vIGNhbGxiYWNrIGZvciByZXNldFxuICAgICAgICByZXNldENhbGxiYWNrOiBmdW5jdGlvbigpIHt9XG4gICAgfTtcblxuXG59KHdpbmRvdy5qUXVlcnkpO1xuIiwiOyhmdW5jdGlvbigpIHtcbiAgdmFyIG1haW5Nb2R1bGUgPSB7fSxcbiAgICAgIHRvVG9wQnRuID0gJCgnI2JhY2stdG8tdG9wJyk7XG5cbiAgcHVibGljTWV0aG9kKCk7XG4gIGluaXQoKTtcbiAgYXR0YWNoRXZlbnRzKCk7XG5cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAkKCcuaW50cm9fX3RleHQxJykudHlwZWQoe1xuICAgICAgc3RyaW5nczogW1wiSSdtIEFudG9uIFBvdnp1bi5cIl0sXG4gICAgICB0eXBlU3BlZWQ6IDUwLFxuICAgICAgc2hvd0N1cnNvcjogZmFsc2UsXG4gICAgICBjYWxsYmFjazogaW50cm9UZXh0MlxuICAgIH0pO1xuICBcbiAgfTtcblxuICBmdW5jdGlvbiBhdHRhY2hFdmVudHMoKSB7XG4gICAgJCh3aW5kb3cpLm9uKCdzY3JvbGwnLCBzaG93VG9Ub3BCdG4pO1xuICAgIHRvVG9wQnRuLm9uKCdjbGljaycsIHNjcm9sbFRvVGhlVG9wKTtcbiAgICAkKCduYXYubWVudScpLm9uKCdjbGljaycsICdhJywgYW5jaG9yU2Nyb2xsKTtcbiAgfTtcblxuICBmdW5jdGlvbiBpbnRyb1RleHQyKCkge1xuICAgICQoJy5pbnRyb19fdGV4dDInKS50eXBlZCh7XG4gICAgICBzdHJpbmdzOiBbJ0Egcm9ib3QgZnJvbSB0aGUgZnV0dXJlJywgJ0EgZnJvbnQtZW5kIGRldmVsb3BlciAnXSxcbiAgICAgIHR5cGVTcGVlZDogNTAsXG4gICAgICBiYWNrRGVsYXk6IDcwMCxcbiAgICAgIHNob3dDdXJzb3I6IGZhbHNlLFxuICAgICAgY2FsbGJhY2s6IGludHJvVGV4dDNcbiAgICAgfSk7XG4gIH07XG4gIFxuXG4gIGZ1bmN0aW9uIGludHJvVGV4dDMoKSB7XG4gICAgJCgnLmludHJvX190ZXh0MycpLnR5cGVkKHtcbiAgICAgIHN0cmluZ3M6IFtcIkkgbGlrZSB0byBtYWtlIGNvb2wgc3R1ZmYuXCJdLFxuICAgICAgc2hvd0N1cnNvcjogZmFsc2UsXG4gICAgICB0eXBlU3BlZWQ6IDUwXG4gICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNob3dUb1RvcEJ0bigpIHtcbiAgICB2YXIgc2Nyb2xsVG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG4gICAgaWYgKHNjcm9sbFRvcCA+IDEwMDApIHtcbiAgICAgIHRvVG9wQnRuLmZhZGVJbig2MDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1RvcEJ0bi5mYWRlT3V0KDYwMCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHNjcm9sbFRvVGhlVG9wKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgaGVhZCA9ICQoJyNoZWFkJyksXG4gICAgICAgIHRvcCA9IGhlYWQub2Zmc2V0KCkudG9wO1xuXG4gICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe3Njcm9sbFRvcDogdG9wfSwgMTAwMCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gYW5jaG9yU2Nyb2xsKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB2YXIgaWQgPSAkKHRoaXMpLmF0dHIoJ2hyZWYnKSxcbiAgICAgICAgdG9wID0gJChpZCkub2Zmc2V0KCkudG9wO1xuXG4gICAgJCgnaHRtbCwgYm9keScpLmFuaW1hdGUoe3Njcm9sbFRvcDogdG9wfSwgMTAwMCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVibGljTWV0aG9kKCkge1xuICAgIG1haW5Nb2R1bGUgPSB7XG4gICAgICBcbiAgICB9XG4gIH07XG5cbiAgd2luZG93Lm1haW5Nb2R1bGUgPSBtYWluTW9kdWxlO1xufSkoKTtcbiIsIjsoZnVuY3Rpb24oKSB7XHJcbiAgdmFyIG15TW9kdWxlID0ge30sXHJcbiAgICAgIGNsb3NlQnRuID0gJCgnI2Nsb3NlJyk7XHJcblxyXG4gIHB1YmxpY01ldGhvZCgpO1xyXG4gIGluaXQoKTtcclxuICBhdHRhY2hFdmVudHMoKTtcclxuXHJcbiAgZnVuY3Rpb24gaW5pdCgpIHtcclxuICAgIC8vIFNvbWUgY29kZS4uZnVuY3Rpb25zIHRoYXQgYXJlIG5lZWRlZCBmb3IgbW9kdWxlIGluaXRpYWxpemF0aW9uIFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGF0dGFjaEV2ZW50cygpIHtcclxuICAgIGNsb3NlQnRuLm9uKCdjbGljaycsIGNsb3NlU2hvd2Nhc2UpO1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGNsb3NlU2hvd2Nhc2UoZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgY29uc29sZS5sb2coJ3NzcycpO1xyXG5cclxuICAgIHZhciBzaG93Y2FzZSA9ICQoJyNzaG93Y2FzZScpLFxyXG4gICAgICAgIGlubmVyU2hvd2Nhc2UgPSAkKCcjaW5uZXItc2hvd2Nhc2UnKTtcclxuXHJcbiAgICBpbm5lclNob3djYXNlLnNsaWRlVXAoMTAwMCk7XHJcbiAgICBzaG93Y2FzZS5mYWRlT3V0KDEwMDAsICdsaW5lYXInKTtcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBwdWJsaWNNZXRob2QoKSB7XHJcbiAgICBteU1vZHVsZSA9IHtcclxuICAgICAgLy8gbmFtZSA6IHB1YmxpYyBmdW5jdGlvblxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHdpbmRvdy5teU1vZHVsZSA9IG15TW9kdWxlO1xyXG59KSgpO1xyXG4iLCJ2YXIgdHlwZSA9IHJlcXVpcmUoJy4uL2Jvd2VyL3R5cGVkLmpzL2pzL3R5cGVkLmpzJyk7XHJcbnZhciBtYWluID0gcmVxdWlyZSgnLi9fbW9kdWxlcy9tYWluLmpzJyk7XHJcbnZhciBzaG93Y2FzZSA9IHJlcXVpcmUoJy4vX21vZHVsZXMvc2hvd2Nhc2UuanMnKTsiXX0=
